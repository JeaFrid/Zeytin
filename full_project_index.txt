

============================================================
FILE: .gitignore
============================================================

# https://dart.dev/guides/libraries/private-files
# Dart & Pub related
.dart_tool/
.packages
.pub-cache/
.pub/
build/

# Project Specific Database & Logs
zeytin/
zeytin_err/
*.log
*.pid
bin/*.exe
project_indexer.py

# Environment & OS files
.env
.DS_Store
Thumbs.db

# Backup files
*.bak
*.tmp

# AI & Indexer Tools (İsteğe bağlı)
full_project_index.txt

============================================================
FILE: ai.md
============================================================

# If I sent this code for an AI to read (and if that AI is you), consider the following warnings:

1. I'm not famous, and when this system goes public, thousands of trucks won't be created. At most, 100 will be created, and that's if we're lucky. So don’t worry about the token system sabotaging RAM.

2. This system will be ported with Nginx and made public. So no problem there.

3. I know tokens will die in a power outage. Already, every time a user makes a request, it goes through token validation, if it doesn't exist, it’s recreated. That's why tokens dying is not an issue. In the worst case, there's a 200ms delay, and that's it, even if everyone’s session ends, it’s fine.

4. I don't know if this system will be popular, and if it does become popular, I don't know if I'll be able to find the money to expand my server's capacity. For this reason, I always expect it to remain small.

5. This system will be released as open source. Therefore, when checking whether it is secure or not, make sure we do not fall into the “security through obscurity” trap.

============================================================
FILE: CHANGELOG.md
============================================================

## 1.0.0

- Initial version.


============================================================
FILE: pubspec.yaml
============================================================

name: zeytin
description: A server app using the shelf package and Docker.
version: 1.0.0
# repository: https://github.com/my_org/my_repo

environment:
  sdk: ^3.10.4

dependencies:
  crypto: ^3.0.7
  dio: ^5.9.1
  encrypt: ^5.0.3
  mime: ^2.0.0
  path: ^1.9.1
  shelf: ^1.4.2
  shelf_multipart: ^2.0.1
  shelf_router: ^1.1.2
  shelf_static: ^1.1.3
  shelf_web_socket: ^3.0.0
  uuid: ^4.5.2
  dart_jsonwebtoken: ^2.7.1
  web_socket_channel: ^3.0.3

dev_dependencies:
  http: ^1.2.2
  lints: ^6.0.0
  test: ^1.25.6


============================================================
FILE: README.md
============================================================



============================================================
FILE: bin/server.dart
============================================================

import 'dart:convert';
import 'package:shelf/shelf.dart';
import 'package:shelf/shelf_io.dart';
import 'package:shelf_router/shelf_router.dart';
import 'package:uuid/uuid.dart';
import 'package:zeytin/html/hello_world.dart';
import 'package:zeytin/logic/engine.dart';
import 'package:zeytin/logic/gatekeeper.dart';
import 'package:zeytin/routes/account.dart';
import 'package:zeytin/routes/call.dart';
import 'package:zeytin/routes/crud.dart';
import 'package:zeytin/routes/storage.dart';
import 'package:zeytin/routes/token.dart';
import 'package:zeytin/routes/watch.dart';

void main() async {
  final router = Router();
  var zeytin = Zeytin("./zeytin");
  var zeytinError = Zeytin("./zeytin_err");

  router.get('/', (Request request) {
    return Response.ok(helloWorldHTML, headers: {'content-type': 'text/html'});
  });
  router.get('/github', (Request request) {
    return Response.found('https://github.com/JeaFrid/zeytin');
  });
  accountRoutes(zeytin, router);
  crudRoutes(zeytin, router);
  tokenRoutes(zeytin, router);
  storageRoutes(zeytin, router);
  watchRoutes(zeytin, router);
  callRoutes(zeytin, router);

  final handler = Pipeline()
      .addMiddleware(logRequests())
      .addMiddleware((innerHandler) {
        return (request) async {
          if (request.method == 'OPTIONS') {
            return Response.ok(
              '',
              headers: {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods':
                    'GET, POST, PUT, DELETE, OPTIONS',
                'Access-Control-Allow-Headers':
                    'Origin, Content-Type, X-Auth-Token, Authorization',
              },
            );
          }
          final response = await innerHandler(request);
          return response.change(
            headers: {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
              'Access-Control-Allow-Headers':
                  'Origin, Content-Type, X-Auth-Token, Authorization',
            },
          );
        };
      })
      .addMiddleware(handleErrorsMiddleware(zeytinError))
      .addMiddleware(jsonResponseMiddleware())
      .addMiddleware(gatekeeperMiddleware())
      .addHandler(router.call);

  final server = await serve(handler, '0.0.0.0', 12852);
  print('The Zeytin server has started on port ${server.port}! Have fun!');
}

Middleware gatekeeperMiddleware() {
  return (innerHandler) {
    return (request) async {
      final securityCheck = await Gatekeeper.check(request);
      if (securityCheck != null) {
        return securityCheck;
      }
      return await innerHandler(request);
    };
  };
}

Middleware handleErrorsMiddleware(Zeytin zeytinError) {
  return (innerHandler) {
    return (request) async {
      if (request.headers['upgrade']?.toLowerCase() == 'websocket') {
        return innerHandler(request);
      }

      try {
        return await innerHandler(request);
      } catch (e, stackTrace) {
        String code = Uuid().v4();
        print("Error Code: $code");
        print("Exception: $e");
        print("StackTrace: $stackTrace");

        await zeytinError.put(
          truckId: "system",
          boxId: "errors",
          tag: code,
          value: {
            "code": code,
            "error": e.toString(),
            "stackTrace": stackTrace.toString(),
            "createdAt": DateTime.now().toIso8601String(),
          },
        );

        return Response.internalServerError(
          body: jsonEncode({
            "isSuccess": false,
            "message": "System Error",
            "error": "Error Code: $code. Contact system administrator.",
          }),
        );
      }
    };
  };
}

Middleware jsonResponseMiddleware() {
  return (innerHandler) {
    return (request) async {
      final response = await innerHandler(request);

      if (response.headers.containsKey('content-type')) {
        return response;
      }

      return response.change(headers: {'content-type': 'application/json'});
    };
  };
}


============================================================
FILE: client/dart/client.dart
============================================================

import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';
import 'package:dio/dio.dart';
import 'package:crypto/crypto.dart';
import 'package:encrypt/encrypt.dart';
import 'package:uuid/uuid.dart';
import 'package:web_socket_channel/web_socket_channel.dart';
const bool isRelease = bool.fromEnvironment('dart.vm.product');
const bool isDebug = !isRelease;


class ZeytinClient {
  String _host = "";
  String _email = "";
  String _password = "";
  String _token = "";
  String _truckID = "";
  String get host => _host;
  String get email => _email;
  String get password => _password;
  String get token => _token;
  String get truck => _truckID;
  late Dio _dioInstance;
  bool _isInitialized = false;

  Dio get _dio {
    if (!_isInitialized) {
      _dioInstance = Dio(
        BaseOptions(
          baseUrl: _host,
          connectTimeout: const Duration(seconds: 10),
          receiveTimeout: const Duration(seconds: 5),
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
        ),
      );
      _isInitialized = true;
    }
    return _dioInstance;
  }

  Future<void> init({
    required String host,
    required String email,
    required String password,
  }) async {
    _host = host;
    _email = email;
    _password = password;
    _dio.options.baseUrl = _host;
    var l = await _login(email: email, password: password);
    if (l.isSuccess) {
      _truckID = l.data?["id"] ?? "";
      ZeytinPrint.successPrint(
        "Hello developer! You are currently connected to the Zeytin server. Keep your code clean!",
      );
      ZeytinPrint.warningPrint("Host: $host");
      ZeytinPrint.warningPrint("Email: $email");
      ZeytinPrint.warningPrint("Truck: $truck");
      Timer.periodic(Duration(seconds: 35), (timer) async {
        await getToken();
      });
    } else {
      ZeytinPrint.warningPrint(
        "Hello developer! I couldn't find a truck for the account you entered.",
      );
      ZeytinPrint.successPrint("A truck has set off for you...");
      var c = await _createAccount(email: email, password: password);
      if (c.isSuccess) {
        ZeytinPrint.successPrint(
          "Hello developer! You are currently connected to the Zeytin server. Keep your code clean!",
        );
        ZeytinPrint.warningPrint("Host: $host");
        ZeytinPrint.warningPrint("Email: $email");
        ZeytinPrint.warningPrint("Truck: $truck");
        Timer.periodic(Duration(seconds: 50), (timer) async {
          await getToken();
        });
      } else {
        ZeytinPrint.errorPrint("There is a problem with the server.");
      }
    }
  }

  Future<ZeytinResponse> _createAccount({
    required String email,
    required String password,
  }) async {
    try {
      Response response = await _dio.post(
        "/truck/create",
        data: {"email": email, "password": password},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      return ZeytinResponse.fromMap(responseData);
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opps...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> _login({
    required String email,
    required String password,
  }) async {
    try {
      Response response = await _dio.post(
        "/truck/id",
        data: {"email": email, "password": password},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      ZeytinResponse zResponse = ZeytinResponse.fromMap(responseData);
      if (zResponse.isSuccess && zResponse.data != null) {
        _email = email;
        _password = password;
        await getToken();
      }
      return zResponse;
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opps...",
        error: e.response?.data != null && e.response?.data is Map
            ? e.response?.data["error"]
            : e.message,
      );
    }
  }

  String getFileUrl({required String fileId}) {
    final String effectiveTruckId = _truckID;
    final String baseUrl = _dio.options.baseUrl;
    final String normalizedBaseUrl = baseUrl.endsWith('/')
        ? baseUrl.substring(0, baseUrl.length - 1)
        : baseUrl;

    return "$normalizedBaseUrl/$effectiveTruckId/$fileId";
  }

  Future<String?> getToken() async {
    try {
      Response response = await _dio.post(
        "/token/create",
        data: {"email": _email, "password": _password},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      ZeytinResponse data = ZeytinResponse.fromMap(responseData);
      if (data.isSuccess && data.data is Map && data.data!["token"] != null) {
        _token = data.data!["token"];
        return _token;
      } else {
        ZeytinPrint.errorPrint(
          data.error ?? "There's an error message received by the client.",
        );
        return null;
      }
    } on DioException catch (e, s) {
      ZeytinPrint.errorPrint(
        "There's an error message received by the client: ${e.message}",
      );
      ZeytinPrint.errorPrint(
        "There's an error message received by the client: $s",
      );
      return null;
    }
  }

  Future<ZeytinResponse> addData({
    required String box,
    required String tag,
    required Map<String, dynamic> value,
  }) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({
        "box": box,
        "tag": tag,
        "value": value,
      });
      Response response = await _dio.post(
        "/data/add",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      return ZeytinResponse.fromMap(responseData);
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> getData({
    required String box,
    required String tag,
  }) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({"box": box, "tag": tag});
      Response response = await _dio.post(
        "/data/get",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      var zResponse = ZeytinResponse.fromMap(responseData, password: _password);
      if (zResponse.isSuccess && zResponse.data != null) {
        return ZeytinResponse(
          isSuccess: true,
          message: "Oki doki!",
          data: zResponse.data,
        );
      }
      return zResponse;
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> deleteData({
    required String box,
    required String tag,
  }) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({"box": box, "tag": tag});
      Response response = await _dio.post(
        "/data/delete",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      return ZeytinResponse.fromMap(responseData);
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> deleteBox({required String box}) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({"box": box});
      Response response = await _dio.post(
        "/data/deleteBox",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      return ZeytinResponse.fromMap(responseData);
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> addBatch({
    required String box,
    required Map<String, Map<String, dynamic>> entries,
  }) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({"box": box, "entries": entries});
      Response response = await _dio.post(
        "/data/addBatch",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      return ZeytinResponse.fromMap(responseData);
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> getBox({required String box}) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({"box": box});
      Response response = await _dio.post(
        "/data/getBox",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;

      var zResponse = ZeytinResponse.fromMap(responseData, password: _password);
      if (zResponse.isSuccess && zResponse.data != null) {
        return ZeytinResponse(
          isSuccess: true,
          message: "Oki doki!",
          data: zResponse.data,
        );
      }
      return zResponse;
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> existsBox({required String box}) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({"box": box});
      Response response = await _dio.post(
        "/data/existsBox",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      var zResponse = ZeytinResponse.fromMap(responseData);
      if (zResponse.isSuccess &&
          zResponse.data != null &&
          zResponse.data!["data"] != null) {
        var decrypted = tokener.decryptMap(zResponse.data!["data"]);
        return ZeytinResponse(
          isSuccess: true,
          message: "Oki doki!",
          data: decrypted,
        );
      }
      return zResponse;
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> existsTag({
    required String box,
    required String tag,
  }) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({"box": box, "tag": tag});
      Response response = await _dio.post(
        "/data/existsTag",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      var zResponse = ZeytinResponse.fromMap(responseData);
      if (zResponse.isSuccess &&
          zResponse.data != null &&
          zResponse.data!["data"] != null) {
        var decrypted = tokener.decryptMap(zResponse.data!["data"]);
        return ZeytinResponse(
          isSuccess: true,
          message: "Oki doki!",
          data: decrypted,
        );
      }
      return zResponse;
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> contains({
    required String box,
    required String tag,
  }) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({"box": box, "tag": tag});
      Response response = await _dio.post(
        "/data/contains",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      var zResponse = ZeytinResponse.fromMap(responseData);
      if (zResponse.isSuccess &&
          zResponse.data != null &&
          zResponse.data!["data"] != null) {
        var decrypted = tokener.decryptMap(zResponse.data!["data"]);
        return ZeytinResponse(
          isSuccess: true,
          message: "Oki doki!",
          data: decrypted,
        );
      }
      return zResponse;
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> search({
    required String box,
    required String field,
    required String prefix,
  }) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({
        "box": box,
        "field": field,
        "prefix": prefix,
      });
      Response response = await _dio.post(
        "/data/search",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      var zResponse = ZeytinResponse.fromMap(responseData);
      if (zResponse.isSuccess &&
          zResponse.data != null &&
          zResponse.data!["data"] != null) {
        var decrypted = tokener.decryptMap(zResponse.data!["data"]);
        return ZeytinResponse(
          isSuccess: true,
          message: "Oki doki!",
          data: decrypted,
        );
      }
      return zResponse;
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> filter({
    required String box,
    required String field,
    required String value,
  }) async {
    try {
      var tokener = ZeytinTokener(_password);
      var encryptedData = tokener.encryptMap({
        "box": box,
        "field": field,
        "value": value,
      });
      Response response = await _dio.post(
        "/data/filter",
        data: {"token": _token, "data": encryptedData},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      var zResponse = ZeytinResponse.fromMap(responseData);
      if (zResponse.isSuccess &&
          zResponse.data != null &&
          zResponse.data!["data"] != null) {
        var decrypted = tokener.decryptMap(zResponse.data!["data"]);
        return ZeytinResponse(
          isSuccess: true,
          message: "Oki doki!",
          data: decrypted,
        );
      }
      return zResponse;
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> uploadFile(String filePath, String fileName) async {
    try {
      var formData = FormData.fromMap({
        "token": _token,
        "file": await MultipartFile.fromFile(filePath, filename: fileName),
      });
      Response response = await _dio.post("/storage/upload", data: formData);
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      return ZeytinResponse.fromMap(responseData);
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Future<ZeytinResponse> deleteToken({
    required String email,
    required String password,
  }) async {
    try {
      Response response = await _dio.delete(
        "/token/delete",
        data: {"email": email, "password": password},
      );
      var responseData = response.data is String
          ? jsonDecode(response.data)
          : response.data;
      return ZeytinResponse.fromMap(responseData);
    } on DioException catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: e.message,
      );
    }
  }

  Stream<Map<String, dynamic>> watchBox({required String box}) {
    var wsUrl = "${_host.replaceFirst("https", "wss")}/data/watch/$_token/$box";
    var channel = WebSocketChannel.connect(Uri.parse(wsUrl));
    var tokener = ZeytinTokener(_password);

    return channel.stream.map((message) {
      var decoded = jsonDecode(message);
      if (decoded["data"] != null) {
        decoded["data"] = tokener.decryptMap(decoded["data"]);
      }
      if (decoded["entries"] != null) {
        decoded["entries"] = tokener.decryptMap(decoded["entries"]);
      }
      return decoded as Map<String, dynamic>;
    });
  }
}

class ZeytinTokener {
  final Key key;
  final Encrypter encrypter;

  ZeytinTokener(String passphrase)
    : key = _deriveKey(passphrase),
      encrypter = Encrypter(AES(_deriveKey(passphrase), mode: AESMode.cbc));

  static Key _deriveKey(String passphrase) {
    final bytes = utf8.encode(passphrase);
    final hash = sha256.convert(bytes).bytes;
    return Key(Uint8List.fromList(hash));
  }

  String encryptMap(Map<String, dynamic> data) {
    final iv = IV.fromSecureRandom(16);
    final plainText = jsonEncode(data);
    final encrypted = encrypter.encrypt(plainText, iv: iv);
    return "${iv.base64}:${encrypted.base64}";
  }

  Map<String, dynamic> decryptMap(String encryptedData) {
    final parts = encryptedData.split(':');
    if (parts.length != 2) {
      throw FormatException("Invalid encrypted data format");
    }
    final iv = IV.fromBase64(parts[0]);
    final cipherText = parts[1];
    final decrypted = encrypter.decrypt(
      Encrypted.fromBase64(cipherText),
      iv: iv,
    );
    return jsonDecode(decrypted) as Map<String, dynamic>;
  }
}

class ZeytinResponse {
  final bool isSuccess;
  final String message;
  final String? error;
  final Map<String, dynamic>? data;

  ZeytinResponse({
    required this.isSuccess,
    required this.message,
    this.error,
    this.data,
  });

  factory ZeytinResponse.fromMap(Map<String, dynamic> map, {String? password}) {
    var rawData = map['data'];
    Map<String, dynamic>? processedData;

    if (rawData != null) {
      if (rawData is Map) {
        processedData = Map<String, dynamic>.from(rawData);
      } else if (rawData is String && password != null) {
        try {
          processedData = ZeytinTokener(password).decryptMap(rawData);
        } catch (e) {
          ZeytinPrint.errorPrint("Şifre çözme hatası: $e");
          processedData = null;
        }
      }
    }

    return ZeytinResponse(
      isSuccess: map['isSuccess'] ?? false,
      message: map['message'] ?? '',
      error: map['error']?.toString(),
      data: processedData,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      "isSuccess": isSuccess,
      "message": message,
      if (error != null) "error": error,
      if (data != null) "data": data,
    };
  }
}

class ZeytinPrint {
  static void successPrint(String data) {
    if (isDebug) {
      print('\x1B[32m[✅]: $data\x1B[0m');
    }
  }

  static void errorPrint(String data) {
    if (isDebug) {
      print('\x1B[31m[❌]: $data\x1B[0m');
    }
  }

  static void warningPrint(String data) {
    if (isDebug) {
      print('\x1B[33m[❗]: $data\x1B[0m');
    }
  }
}

class ZeytinSocialCommentsModel {
  final ZeytinUserResponse? user;
  final String? text;
  final String? id;
  final String? postID;
  final List<String>? likes;
  final Map<String, dynamic>? moreData;
  ZeytinSocialCommentsModel(
    this.user,
    this.text,
    this.likes,
    this.postID,
    this.id,
    this.moreData,
  );
  Map<String, dynamic> toJson() {
    return {
      "user": user?.toJson() ?? {},
      "text": text ?? "",
      "id": id ?? "",
      "likes": likes ?? [],
      "post": postID ?? "",
      "moreData": moreData ?? {},
    };
  }

  ZeytinSocialCommentsModel copyWith({
    ZeytinUserResponse? user,
    String? text,
    List<String>? likes,
    String? postID,
    String? id,
    Map<String, dynamic>? moreData,
  }) {
    return ZeytinSocialCommentsModel(
      user ?? this.user,
      text ?? this.text,
      likes ?? this.likes,
      postID ?? this.postID,
      id ?? this.id,
      moreData ?? this.moreData,
    );
  }

  factory ZeytinSocialCommentsModel.fromJson(Map<String, dynamic> data) {
    return ZeytinSocialCommentsModel(
      data["user"] != null ? ZeytinUserResponse.fromJson(data["user"]) : null,
      data["text"],
      (data["likes"] as List?)?.cast<String>() ?? [],
      data["postID"] ?? "",
      data["id"],
      data["moreData"] ?? {},
    );
  }
}

class ZeytinSocialModel {
  final ZeytinUserResponse? user;
  final String? text;
  final String? id;
  String? category;
  final List<String>? images;
  final List<String>? docs;
  final List<String>? locations;
  final List<String>? likes;
  final List<ZeytinSocialCommentsModel>? comments;
  final Map<String, dynamic>? moreData;
  ZeytinSocialModel({
    this.moreData,
    this.user,
    this.category,
    this.text,
    this.images,
    this.docs,
    this.locations,
    this.id,
    this.likes,
    this.comments,
  });
  Map<String, dynamic> toJson() {
    List<Map<String, dynamic>> coms = [];
    if (comments != null) {
      for (var element in comments!) {
        coms.add(element.toJson());
      }
    }

    return {
      "user": user?.toJson() ?? {},
      "text": text ?? "",
      "images": images ?? [],
      "docs": docs ?? [],
      "category": category ?? "",
      "locations": locations ?? [],
      "id": id ?? "",
      "moreData": moreData ?? {},
      "likes": likes ?? [],
      "comments": comments == null ? [] : coms,
    };
  }

  ZeytinSocialModel copyWith({
    ZeytinUserResponse? user,
    String? text,
    String? category,
    String? id,
    List<String>? images,
    List<String>? docs,
    List<String>? locations,
    List<String>? likes,
    List<ZeytinSocialCommentsModel>? comments,
    Map<String, dynamic>? moreData,
  }) {
    return ZeytinSocialModel(
      user: user ?? this.user,
      text: text ?? this.text,
      category: category ?? this.category,
      images: images ?? this.images,
      docs: docs ?? this.docs,
      locations: locations ?? this.locations,
      id: id ?? this.id,
      likes: likes ?? this.likes,
      comments: comments ?? this.comments,
      moreData: moreData ?? this.moreData,
    );
  }

  factory ZeytinSocialModel.fromJson(Map<String, dynamic> data) {
    List<ZeytinSocialCommentsModel> coms = [];
    for (var element in data["comments"]) {
      coms.add(ZeytinSocialCommentsModel.fromJson(element));
    }

    return ZeytinSocialModel(
      user: ZeytinUserResponse.fromJson(data["user"]),
      text: data["text"] ?? "",
      images: data["images"] ?? [],
      category: data["category"] ?? "",
      docs: data["docs"] ?? [],
      locations: data["locations"] ?? [],
      id: data["id"] ?? "",
      likes: (data["likes"] as List?)?.cast<String>() ?? [],
      comments: coms,
      moreData: data["moreData"] ?? {},
    );
  }
}

class ZeytinSocial {
  ZeytinClient zeytin;
  ZeytinSocial(this.zeytin);
  Future<ZeytinResponse> createPost({
    required ZeytinSocialModel postModel,
  }) async {
    String id = Uuid().v1();

    return await zeytin.addData(
      box: "social",
      tag: id,
      value: postModel.copyWith(id: id).toJson(),
    );
  }

  Future<ZeytinResponse> editPost({
    required String id,
    required ZeytinSocialModel postModel,
  }) async {
    return await zeytin.addData(
      box: "social",
      tag: id,
      value: postModel.copyWith(id: id).toJson(),
    );
  }

  Future<ZeytinResponse> addLike({
    required ZeytinUserResponse user,
    required String postID,
  }) async {
    ZeytinSocialModel post = await getPost(id: postID);
    if ((post.likes ?? []).contains(user.uid)) {
      return ZeytinResponse(isSuccess: true, message: "message");
    } else {
      List<String> likes = (post.likes ?? []);
      likes.add(user.uid);
      ZeytinSocialModel newPost = post.copyWith(likes: likes);
      await editPost(id: postID, postModel: newPost);
      return ZeytinResponse(isSuccess: true, message: "message");
    }
  }

  Future<ZeytinResponse> removeLike({
    required ZeytinUserResponse user,
    required String postID,
  }) async {
    ZeytinSocialModel post = await getPost(id: postID);
    if ((post.likes ?? []).contains(user.uid)) {
      List<String> likes = (post.likes ?? []);
      likes.remove(user.uid);
      ZeytinSocialModel newPost = post.copyWith(likes: likes);
      await editPost(id: postID, postModel: newPost);
      return ZeytinResponse(isSuccess: true, message: "message");
    } else {
      return ZeytinResponse(isSuccess: true, message: "message");
    }
  }

  Future<ZeytinResponse> addComment({
    required ZeytinSocialCommentsModel comment,
    required String postID,
  }) async {
    ZeytinSocialModel post = await getPost(id: postID);
    List<ZeytinSocialCommentsModel> comments = [];
    comments = post.comments ?? [];
    comments.add(comment.copyWith(id: Uuid().v1()));
    ZeytinSocialModel newPost = post.copyWith(comments: comments);
    await editPost(id: postID, postModel: newPost);
    return ZeytinResponse(isSuccess: true, message: "ok");
  }

  Future<ZeytinResponse> deleteComment({
    required String commentID,
    required String postID,
  }) async {
    ZeytinSocialModel post = await getPost(id: postID);
    List<ZeytinSocialCommentsModel> comments = [];
    comments = post.comments ?? [];
    comments.removeWhere((element) => element.id == commentID);
    ZeytinSocialModel newPost = post.copyWith(comments: comments);
    await editPost(id: postID, postModel: newPost);
    return ZeytinResponse(isSuccess: true, message: "ok");
  }

  Future<ZeytinResponse> addCommentLike({
    required ZeytinUserResponse user,
    required String postID,
    required String commentID,
  }) async {
    ZeytinSocialModel post = await getPost(id: postID);

    List<ZeytinSocialCommentsModel> comments = post.comments ?? [];
    bool updated = false;

    for (int i = 0; i < comments.length; i++) {
      if (comments[i].id == commentID) {
        List<String> commentLikes = comments[i].likes ?? [];

        if (!commentLikes.contains(user.uid)) {
          commentLikes.add(user.uid);
          comments[i] = ZeytinSocialCommentsModel(
            comments[i].user,
            comments[i].text,
            commentLikes,
            comments[i].postID,
            comments[i].id,
            comments[i].moreData,
          );
          updated = true;
        }
        break;
      }
    }

    if (updated) {
      ZeytinSocialModel newPost = post.copyWith(comments: comments);
      await editPost(id: postID, postModel: newPost);
      return ZeytinResponse(isSuccess: true, message: "Comment liked");
    }

    return ZeytinResponse(
      isSuccess: false,
      message: "No comments found or it's already liked.",
    );
  }

  Future<ZeytinResponse> removeCommentLike({
    required ZeytinUserResponse user,
    required String postID,
    required String commentID,
  }) async {
    ZeytinSocialModel post = await getPost(id: postID);

    List<ZeytinSocialCommentsModel> comments = post.comments ?? [];
    bool updated = false;

    for (int i = 0; i < comments.length; i++) {
      if (comments[i].id == commentID) {
        List<String> commentLikes = comments[i].likes ?? [];

        if (commentLikes.contains(user.uid)) {
          commentLikes.remove(user.uid);
          comments[i] = ZeytinSocialCommentsModel(
            comments[i].user,
            comments[i].text,
            commentLikes,
            comments[i].postID,
            comments[i].id,
            comments[i].moreData,
          );
          updated = true;
        }
        break;
      }
    }

    if (updated) {
      ZeytinSocialModel newPost = post.copyWith(comments: comments);
      await editPost(id: postID, postModel: newPost);
      return ZeytinResponse(isSuccess: true, message: "Comment like removed");
    }

    return ZeytinResponse(
      isSuccess: false,
      message: "No comments or likes found.",
    );
  }

  Future<List<ZeytinSocialCommentsModel>> getComments({
    required String postID,
    int? limit,
    int? offset,
  }) async {
    ZeytinSocialModel post = await getPost(id: postID);
    List<ZeytinSocialCommentsModel> allComments = post.comments ?? [];

    if (offset != null && offset >= allComments.length) {
      return [];
    }

    int startIndex = offset ?? 0;
    int endIndex = limit != null ? startIndex + limit : allComments.length;

    if (endIndex > allComments.length) {
      endIndex = allComments.length;
    }

    if (startIndex >= endIndex) {
      return [];
    }

    return allComments.sublist(startIndex, endIndex);
  }

  Future<ZeytinSocialModel> getPost({required String id}) async {
    var post = await zeytin.getData(box: "social", tag: id);
    return ZeytinSocialModel.fromJson(post.data ?? {});
  }

  Future<List<ZeytinSocialModel>> getAllPost() async {
    List<ZeytinSocialModel> list = [];
    var social = await zeytin.getBox(box: "social");
    for (var element in social.data!.keys) {
      list.add(ZeytinSocialModel.fromJson(social.data![element]));
    }

    return list;
  }
}

class ZeytinBaseUser {
  ZeytinClient zeytin;
  ZeytinBaseUser(this.zeytin);
  Future<ZeytinResponse> create(
    String name,
    String email,
    String password,
  ) async {
    try {
      bool existEmail = await exist(email);
      if (existEmail) {
        return ZeytinResponse(
          isSuccess: false,
          message: "Email available",
          error: "This email is already registered.",
        );
      } else {
        String uid = const Uuid().v1();
        var emptyUser = ZeytinUserResponse.empty();
        var newUser = emptyUser.copyWith(
          uid: uid,
          username: name,
          email: email,
          password: password,
          accountCreation: DateTime.now().toIso8601String(),
        );
        var res = await zeytin.addData(
          box: "users",
          tag: uid,
          value: newUser.toJson(),
        );

        if (res.isSuccess) {
          return ZeytinResponse(
            isSuccess: true,
            message: "ok",
            data: newUser.toJson(),
          );
        }
        return res;
      }
    } catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Error",
        error: e.toString(),
      );
    }
  }

  Future<bool> exist(String email) async {
    var res = await zeytin.getBox(box: "users");
    for (var element in res.data?.keys ?? []) {
      var user = ZeytinUserResponse.fromJson(res.data![element]);

      if (user.email.toLowerCase() == email.toLowerCase()) {
        return true;
      }
    }
    return false;
  }

  Future<ZeytinResponse> login(String email, String password) async {
    try {
      bool existE = await exist(email);
      if (existE) {
        var res = await zeytin.getBox(box: "users");

        for (var element in res.data!.keys) {
          var val = res.data![element];
          if (val["email"].toString().toLowerCase() == email.toLowerCase()) {}
          if (val["email"].toString().toLowerCase() == email.toLowerCase() &&
              val["password"].toString().trim() == password.toString().trim()) {
            return ZeytinResponse(isSuccess: true, message: "ok", data: val);
          }
        }
        return ZeytinResponse(isSuccess: false, message: "Wrong password");
      } else {
        return ZeytinResponse(isSuccess: false, message: "Account not found");
      }
    } catch (e) {
      ZeytinPrint.errorPrint(e.toString());
      return ZeytinResponse(
        isSuccess: false,
        message: "Opps...",
        error: e.toString(),
      );
    }
  }

  Future<ZeytinUserResponse?> getProfile({required String userId}) async {
    try {
      final userData = await zeytin.getData(box: "users", tag: userId);
      if (userData.data == null) return null;
      return ZeytinUserResponse.fromJson(userData.data!);
    } catch (e) {
      return null;
    }
  }

  Future<List<ZeytinUserResponse>> getAllProfile() async {
    try {
      final allUsers = await zeytin.getBox(box: "users");
      List<ZeytinUserResponse> users = [];
      for (var element in allUsers.data!.keys) {
        users.add(ZeytinUserResponse.fromJson(allUsers.data![element]));
      }
      return users;
    } catch (e) {
      return [];
    }
  }

  Future<ZeytinResponse> updateProfile(ZeytinUserResponse user) async {
    try {
      var res = await zeytin.addData(
        box: "users",
        tag: user.uid,
        value: user.toJson(),
      );
      if (res.isSuccess) {
        return ZeytinResponse(
          isSuccess: true,
          message: "ok",
          data: user.toJson(),
        );
      } else {
        return res;
      }
    } catch (e) {
      return ZeytinResponse(
        isSuccess: false,
        message: e.toString(),
        error: e.toString(),
      );
    }
  }
}

class RevaniChat {
  ZeytinClient zeytin;
  RevaniChat(this.zeytin);

  Future<ZeytinResponse> createChat({
    required String chatId,
    required String chatName,
    required List<String> participantIds,
    required String type,
    String? chatPhotoURL,
    List<String>? adminIds,
    Map<String, dynamic>? themeSettings,
    String? disappearingMessagesTimer,
  }) async {
    try {
      final chat = Chat(
        chatID: chatId,
        chatName: chatName,
        chatPhotoURL: chatPhotoURL,
        type: type,
        adminIDs: adminIds ?? (type == "private" ? [] : participantIds),
        themeSettings: themeSettings,
        disappearingMessagesTimer: disappearingMessagesTimer,
        participants: null,
        createdAt: DateTime.now(),
      );

      return await zeytin.addData(
        box: "chats",
        tag: chatId,
        value: chat.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> sendMessage({
    required String chatId,
    required String senderId,
    required String text,
    String? messageType,
    RevaniMedia? media,
    RevaniLocation? location,
    RevaniContact? contact,
    String? replyToMessageId,
    List<String>? mentions,
    Duration? selfDestructTimer,
    String? botId,
    List<RevaniInteractiveButton>? interactiveButtons,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final messageId = Uuid().v1();
      final now = DateTime.now();
      final selfDestructTimestamp = selfDestructTimer != null
          ? now.add(selfDestructTimer)
          : null;

      final message = RevaniMessage(
        messageId: messageId,
        chatId: chatId,
        senderId: senderId,
        text: text,
        timestamp: now,
        messageType: messageType ?? 'text',
        status: 'sent',
        media: media,
        location: location,
        contact: contact,
        replyToMessageId: replyToMessageId,
        mentions: mentions ?? [],
        selfDestructTimer: selfDestructTimer,
        selfDestructTimestamp: selfDestructTimestamp,
        botId: botId,
        interactiveButtons: interactiveButtons ?? [],
        metadata: metadata ?? {},
      );

      final response = await zeytin.addData(
        box: "messages",
        tag: messageId,
        value: message.toJson(),
      );

      if (response.isSuccess == true) {
        await _updateChatLastMessage(chatId, message);
      }

      return response;
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<List<RevaniMessage>> getMessages({
    required String chatId,
    int? limit,
    int? offset,
    String? beforeMessageId,
    DateTime? beforeTimestamp,
  }) async {
    try {
      final allMessages = await zeytin.getBox(box: "messages");

      List<RevaniMessage> chatMessages = [];
      for (var item in allMessages.data!.values) {
        final message = RevaniMessage.fromJson(item.value);
        if (message.chatId == chatId) {
          chatMessages.add(message);
        }
      }

      chatMessages.sort((a, b) => b.timestamp.compareTo(a.timestamp));

      if (beforeMessageId != null) {
        final index = chatMessages.indexWhere(
          (m) => m.messageId == beforeMessageId,
        );
        if (index != -1) {
          chatMessages = chatMessages.sublist(index + 1);
        }
      } else if (beforeTimestamp != null) {
        chatMessages = chatMessages
            .where((m) => m.timestamp.isBefore(beforeTimestamp))
            .toList();
      }

      final startIndex = offset ?? 0;
      final endIndex = limit != null
          ? (startIndex + limit).clamp(0, chatMessages.length)
          : chatMessages.length;

      if (startIndex >= chatMessages.length) {
        return [];
      }

      return chatMessages.sublist(startIndex, endIndex).reversed.toList();
    } catch (e) {
      return [];
    }
  }

  Future<ZeytinResponse> editMessage({
    required String messageId,
    required String newText,
    String? editedBy,
  }) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      var message = RevaniMessage.fromJson(messageData.data!);

      if (message.isDeleted) {
        return ZeytinResponse(
          isSuccess: false,
          message: "Cannot edit deleted message",
        );
      }

      message = message.copyWith(
        text: newText,
        isEdited: true,
        editedTimestamp: DateTime.now(),
      );

      return await zeytin.addData(
        box: "messages",
        tag: messageId,
        value: message.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> deleteMessage({
    required String messageId,
    required String userId,
    bool deleteForEveryone = false,
  }) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      var message = RevaniMessage.fromJson(messageData.data!);

      if (message.senderId != userId && !deleteForEveryone) {
        return ZeytinResponse(isSuccess: false, message: "Not authorized");
      }

      message = message.copyWith(
        isDeleted: true,
        deletedForEveryone: deleteForEveryone,
      );

      return await zeytin.addData(
        box: "messages",
        tag: messageId,
        value: message.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> addReaction({
    required String messageId,
    required String userId,
    required String emoji,
  }) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      var message = RevaniMessage.fromJson(messageData.data!);

      final existingReactions = message.reactions.reactions;
      final reactionsForEmoji = existingReactions[emoji] ?? [];

      final alreadyReacted = reactionsForEmoji.any((r) => r.userId == userId);
      if (alreadyReacted) {
        return ZeytinResponse(isSuccess: true, message: "Already reacted");
      }

      final newReaction = RevaniReaction(
        emoji: emoji,
        userId: userId,
        timestamp: DateTime.now(),
      );

      reactionsForEmoji.add(newReaction);
      existingReactions[emoji] = reactionsForEmoji;

      message = message.copyWith(
        reactions: RevaniMessageReactions(reactions: existingReactions),
      );

      return await zeytin.addData(
        box: "messages",
        tag: messageId,
        value: message.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> removeReaction({
    required String messageId,
    required String userId,
    required String emoji,
  }) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      var message = RevaniMessage.fromJson(messageData.data!);

      final existingReactions = message.reactions.reactions;
      final reactionsForEmoji = existingReactions[emoji] ?? [];

      final index = reactionsForEmoji.indexWhere((r) => r.userId == userId);
      if (index == -1) {
        return ZeytinResponse(isSuccess: true, message: "Reaction not found");
      }

      reactionsForEmoji.removeAt(index);

      if (reactionsForEmoji.isEmpty) {
        existingReactions.remove(emoji);
      } else {
        existingReactions[emoji] = reactionsForEmoji;
      }

      message = message.copyWith(
        reactions: RevaniMessageReactions(reactions: existingReactions),
      );

      return await zeytin.addData(
        box: "messages",
        tag: messageId,
        value: message.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> markAsRead({
    required String messageId,
    required String userId,
  }) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      var message = RevaniMessage.fromJson(messageData.data!);

      final readBy = message.statusInfo.readBy;
      if (!readBy.contains(userId)) {
        readBy.add(userId);
      }

      final statusInfo = message.statusInfo.copyWith(
        readBy: readBy,
        readAt: readBy.length == 1 ? DateTime.now() : message.statusInfo.readAt,
      );

      message = message.copyWith(statusInfo: statusInfo);

      return await zeytin.addData(
        box: "messages",
        tag: messageId,
        value: message.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> markAsDelivered({
    required String messageId,
    required String userId,
  }) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      var message = RevaniMessage.fromJson(messageData.data!);

      final deliveredTo = message.statusInfo.deliveredTo;
      if (!deliveredTo.contains(userId)) {
        deliveredTo.add(userId);
      }

      final statusInfo = message.statusInfo.copyWith(
        deliveredTo: deliveredTo,
        deliveredAt: deliveredTo.length == 1
            ? DateTime.now()
            : message.statusInfo.deliveredAt,
      );

      message = message.copyWith(statusInfo: statusInfo);

      return await zeytin.addData(
        box: "messages",
        tag: messageId,
        value: message.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> forwardMessage({
    required String originalMessageId,
    required String targetChatId,
    required String senderId,
  }) async {
    try {
      final messageData = await zeytin.getData(
        box: "messages",
        tag: originalMessageId,
      );

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      final originalMessage = RevaniMessage.fromJson(messageData.data!);

      final newMessageId = Uuid().v1();
      final now = DateTime.now();

      final forwardedMessage = RevaniMessage(
        messageId: newMessageId,
        chatId: targetChatId,
        senderId: senderId,
        text: originalMessage.text,
        timestamp: now,
        messageType: originalMessage.messageType,
        status: 'sent',
        isForwarded: true,
        forwardedFrom: originalMessage.senderId,
        media: originalMessage.media,
        location: originalMessage.location,
        contact: originalMessage.contact,
        mentions: originalMessage.mentions,
      );

      final response = await zeytin.addData(
        box: "messages",
        tag: newMessageId,
        value: forwardedMessage.toJson(),
      );

      if (response.isSuccess == true) {
        await _updateChatLastMessage(targetChatId, forwardedMessage);
      }

      return response;
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> pinMessage({
    required String messageId,
    required String pinnedBy,
    required String chatId,
  }) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      var message = RevaniMessage.fromJson(messageData.data!);

      if (message.chatId != chatId) {
        return ZeytinResponse(
          isSuccess: false,
          message: "Message not in this chat",
        );
      }

      message = message.copyWith(
        isPinned: true,
        pinnedBy: pinnedBy,
        pinnedTimestamp: DateTime.now(),
      );

      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data != null) {
        var chat = Chat.fromJson(chatData.data!);
        final pinnedMessageIDs = chat.pinnedMessageIDs ?? [];
        if (!pinnedMessageIDs.contains(messageId)) {
          pinnedMessageIDs.add(messageId);
          chat = chat.copyWith(pinnedMessageIDs: pinnedMessageIDs);
          await zeytin.addData(box: "chats", tag: chatId, value: chat.toJson());
        }
      }

      return await zeytin.addData(
        box: "messages",
        tag: messageId,
        value: message.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> unpinMessage({
    required String messageId,
    required String chatId,
  }) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      var message = RevaniMessage.fromJson(messageData.data!);

      message = message.copyWith(
        isPinned: false,
        pinnedBy: null,
        pinnedTimestamp: null,
      );

      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data != null) {
        var chat = Chat.fromJson(chatData.data!);
        final pinnedMessageIDs = chat.pinnedMessageIDs ?? [];
        pinnedMessageIDs.remove(messageId);
        chat = chat.copyWith(pinnedMessageIDs: pinnedMessageIDs);
        await zeytin.addData(box: "chats", tag: chatId, value: chat.toJson());
      }

      return await zeytin.addData(
        box: "messages",
        tag: messageId,
        value: message.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> starMessage({
    required String messageId,
    required String userId,
  }) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      var message = RevaniMessage.fromJson(messageData.data!);

      final starredBy = message.starredBy;
      if (!starredBy.contains(userId)) {
        starredBy.add(userId);
        message = message.copyWith(starredBy: starredBy);

        return await zeytin.addData(
          box: "messages",
          tag: messageId,
          value: message.toJson(),
        );
      }

      return ZeytinResponse(isSuccess: true, message: "Already starred");
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> unstarMessage({
    required String messageId,
    required String userId,
  }) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);

      if (messageData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Message not found");
      }

      var message = RevaniMessage.fromJson(messageData.data!);

      final starredBy = message.starredBy;
      if (starredBy.contains(userId)) {
        starredBy.remove(userId);
        message = message.copyWith(starredBy: starredBy);

        return await zeytin.addData(
          box: "messages",
          tag: messageId,
          value: message.toJson(),
        );
      }

      return ZeytinResponse(isSuccess: true, message: "Not starred");
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<List<Chat>> getChatsForUser({
    required String userId,
    int? limit,
    int? offset,
  }) async {
    try {
      final allChats = await zeytin.getBox(box: "chats");

      List<Chat> userChats = [];
      for (var item in allChats.data!.values) {
        final chat = Chat.fromJson(item.value);

        final chatData = await zeytin.getData(
          box: "chats",
          tag: chat.chatID ?? "",
        );
        if (chatData.data != null) {
          userChats.add(chat);
        }
      }

      userChats.sort((a, b) {
        final aTime = a.lastMessageTimestamp ?? DateTime(1970);
        final bTime = b.lastMessageTimestamp ?? DateTime(1970);
        return bTime.compareTo(aTime);
      });

      final startIndex = offset ?? 0;
      final endIndex = limit != null
          ? (startIndex + limit).clamp(0, userChats.length)
          : userChats.length;

      if (startIndex >= userChats.length) {
        return [];
      }

      return userChats.sublist(startIndex, endIndex);
    } catch (e) {
      return [];
    }
  }

  Future<Chat?> getChat({required String chatId}) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data == null) return null;
      return Chat.fromJson(chatData.data!);
    } catch (e) {
      return null;
    }
  }

  Future<ZeytinResponse> updateChat({
    required String chatId,
    String? chatName,
    String? chatPhotoURL,
    Map<String, dynamic>? themeSettings,
    bool? isMuted,
    bool? isArchived,
    bool? isBlocked,
    String? disappearingMessagesTimer,
    List<String>? adminIDs,
  }) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Chat not found");
      }

      var chat = Chat.fromJson(chatData.data!);

      chat = chat.copyWith(
        chatName: chatName ?? chat.chatName,
        chatPhotoURL: chatPhotoURL ?? chat.chatPhotoURL,
        themeSettings: themeSettings ?? chat.themeSettings,
        isMuted: isMuted ?? chat.isMuted,
        isArchived: isArchived ?? chat.isArchived,
        isBlocked: isBlocked ?? chat.isBlocked,
        disappearingMessagesTimer:
            disappearingMessagesTimer ?? chat.disappearingMessagesTimer,
        adminIDs: adminIDs ?? chat.adminIDs,
      );

      return await zeytin.addData(
        box: "chats",
        tag: chatId,
        value: chat.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> addParticipant({
    required String chatId,
    required String userId,
  }) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Chat not found");
      }

      final chat = Chat.fromJson(chatData.data!);
      final participants = chat.participants ?? [];

      final userResponse = await _getUserResponse(userId);
      if (userResponse == null) {
        return ZeytinResponse(isSuccess: false, message: "User not found");
      }

      final alreadyParticipant = participants.any((p) => p.uid == userId);
      if (alreadyParticipant) {
        return ZeytinResponse(
          isSuccess: true,
          message: "Already a participant",
        );
      }

      final newParticipants = [...participants, userResponse];
      final updatedChat = chat.copyWith(participants: newParticipants);

      return await zeytin.addData(
        box: "chats",
        tag: chatId,
        value: updatedChat.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> removeParticipant({
    required String chatId,
    required String userId,
  }) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Chat not found");
      }

      final chat = Chat.fromJson(chatData.data!);
      final participants = chat.participants ?? [];

      final updatedParticipants = participants
          .where((p) => p.uid != userId)
          .toList();
      final updatedChat = chat.copyWith(participants: updatedParticipants);

      return await zeytin.addData(
        box: "chats",
        tag: chatId,
        value: updatedChat.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> createSystemMessage({
    required String chatId,
    required String type,
    String? userId,
    String? userName,
    String? oldValue,
    String? value,
  }) async {
    try {
      final messageId = Uuid().v1();
      final now = DateTime.now();

      final systemMessageData = RevaniSystemMessageData(
        type: type,
        userId: userId,
        userName: userName,
        oldValue: oldValue,
        value: value,
      );

      final message = RevaniMessage(
        messageId: messageId,
        chatId: chatId,
        senderId: "system",
        text: _getSystemMessageText(type, userName, oldValue, value),
        timestamp: now,
        messageType: 'system',
        status: 'sent',
        isSystemMessage: true,
        systemMessageData: systemMessageData,
      );

      final response = await zeytin.addData(
        box: "messages",
        tag: messageId,
        value: message.toJson(),
      );

      if (response.isSuccess == true) {
        await _updateChatLastMessage(chatId, message);
      }

      return response;
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<List<RevaniMessage>> searchMessages({
    required String chatId,
    required String query,
    int? limit,
    int? offset,
  }) async {
    try {
      final allMessages = await zeytin.getBox(box: "messages");

      List<RevaniMessage> matchingMessages = [];
      for (var item in allMessages.data!.values) {
        final message = RevaniMessage.fromJson(item.value);
        if (message.chatId == chatId &&
            !message.isDeleted &&
            message.text.toLowerCase().contains(query.toLowerCase())) {
          matchingMessages.add(message);
        }
      }

      matchingMessages.sort((a, b) => b.timestamp.compareTo(a.timestamp));

      final startIndex = offset ?? 0;
      final endIndex = limit != null
          ? (startIndex + limit).clamp(0, matchingMessages.length)
          : matchingMessages.length;

      if (startIndex >= matchingMessages.length) {
        return [];
      }

      return matchingMessages.sublist(startIndex, endIndex);
    } catch (e) {
      return [];
    }
  }

  Future<ZeytinResponse> setTyping({
    required String chatId,
    required String userId,
    required bool isTyping,
  }) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Chat not found");
      }

      var chat = Chat.fromJson(chatData.data!);
      var typingUserIDs = chat.typingUserIDs ?? [];

      if (isTyping) {
        if (!typingUserIDs.contains(userId)) {
          typingUserIDs.add(userId);
        }
      } else {
        typingUserIDs.remove(userId);
      }

      chat = chat.copyWith(typingUserIDs: typingUserIDs);

      return await zeytin.addData(
        box: "chats",
        tag: chatId,
        value: chat.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<List<RevaniMessage>> getStarredMessages({
    required String userId,
    int? limit,
    int? offset,
  }) async {
    try {
      final allMessages = await zeytin.getBox(box: "messages");

      List<RevaniMessage> starredMessages = [];
      for (var item in allMessages.data!.values) {
        final message = RevaniMessage.fromJson(item.value);
        if (message.starredBy.contains(userId) && !message.isDeleted) {
          starredMessages.add(message);
        }
      }

      starredMessages.sort((a, b) => b.timestamp.compareTo(a.timestamp));

      final startIndex = offset ?? 0;
      final endIndex = limit != null
          ? (startIndex + limit).clamp(0, starredMessages.length)
          : starredMessages.length;

      if (startIndex >= starredMessages.length) {
        return [];
      }

      return starredMessages.sublist(startIndex, endIndex);
    } catch (e) {
      return [];
    }
  }

  Future<ZeytinResponse> updateUnreadCount({
    required String chatId,
    required String userId,
    int? unreadCount,
  }) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data == null) {
        return ZeytinResponse(isSuccess: false, message: "Chat not found");
      }

      var chat = Chat.fromJson(chatData.data!);

      if (unreadCount != null) {
        chat = chat.copyWith(unreadCount: unreadCount);
      } else {
        final messages = await getMessages(chatId: chatId, limit: 100);
        final unread = messages.where((m) {
          return m.senderId != userId &&
              !m.statusInfo.readBy.contains(userId) &&
              !m.isDeleted;
        }).length;

        chat = chat.copyWith(unreadCount: unread);
      }

      return await zeytin.addData(
        box: "chats",
        tag: chatId,
        value: chat.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<List<RevaniMessage>> getPinnedMessages({
    required String chatId,
    int? limit,
    int? offset,
  }) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data == null) return [];

      final chat = Chat.fromJson(chatData.data!);
      final pinnedMessageIDs = chat.pinnedMessageIDs ?? [];

      List<RevaniMessage> pinnedMessages = [];
      for (var messageId in pinnedMessageIDs) {
        final messageData = await zeytin.getData(
          box: "messages",
          tag: messageId,
        );
        if (messageData.data != null) {
          final message = RevaniMessage.fromJson(messageData.data!);
          if (!message.isDeleted) {
            pinnedMessages.add(message);
          }
        }
      }

      pinnedMessages.sort((a, b) {
        final aTime = a.pinnedTimestamp ?? DateTime(1970);
        final bTime = b.pinnedTimestamp ?? DateTime(1970);
        return bTime.compareTo(aTime);
      });

      final startIndex = offset ?? 0;
      final endIndex = limit != null
          ? (startIndex + limit).clamp(0, pinnedMessages.length)
          : pinnedMessages.length;

      if (startIndex >= pinnedMessages.length) {
        return [];
      }

      return pinnedMessages.sublist(startIndex, endIndex);
    } catch (e) {
      return [];
    }
  }

  Future<ZeytinResponse> clearChatHistory({
    required String chatId,
    required String userId,
    bool deleteForEveryone = false,
  }) async {
    try {
      final messages = await getMessages(chatId: chatId, limit: 1000);

      for (var message in messages) {
        if (deleteForEveryone || message.senderId == userId) {
          await deleteMessage(
            messageId: message.messageId,
            userId: userId,
            deleteForEveryone: deleteForEveryone,
          );
        }
      }

      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data != null) {
        var chat = Chat.fromJson(chatData.data!);
        chat = chat.copyWith(
          lastMessage: null,
          lastMessageTimestamp: null,
          lastMessageSenderID: null,
          unreadCount: 0,
        );

        await zeytin.addData(box: "chats", tag: chatId, value: chat.toJson());
      }

      return ZeytinResponse(isSuccess: true, message: "Chat history cleared");
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<RevaniMessage?> getMessage({required String messageId}) async {
    try {
      final messageData = await zeytin.getData(box: "messages", tag: messageId);
      if (messageData.data == null) return null;
      return RevaniMessage.fromJson(messageData.data!);
    } catch (e) {
      return null;
    }
  }

  Future<ZeytinResponse> archiveChat({
    required String chatId,
    required bool archive,
  }) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data != null) {
        return ZeytinResponse(isSuccess: false, message: "Chat not found");
      }

      var chat = Chat.fromJson(chatData.data!);
      chat = chat.copyWith(isArchived: archive);

      return await zeytin.addData(
        box: "chats",
        tag: chatId,
        value: chat.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> muteChat({
    required String chatId,
    required bool mute,
  }) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data != null) {
        return ZeytinResponse(isSuccess: false, message: "Chat not found");
      }

      var chat = Chat.fromJson(chatData.data!);
      chat = chat.copyWith(isMuted: mute);

      return await zeytin.addData(
        box: "chats",
        tag: chatId,
        value: chat.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> blockChat({
    required String chatId,
    required bool block,
  }) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data != null) {
        return ZeytinResponse(isSuccess: false, message: "Chat not found");
      }

      var chat = Chat.fromJson(chatData.data!);
      chat = chat.copyWith(isBlocked: block);

      return await zeytin.addData(
        box: "chats",
        tag: chatId,
        value: chat.toJson(),
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinResponse> processSelfDestructMessages() async {
    try {
      final allMessages = await zeytin.getBox(box: "messages");
      final now = DateTime.now();

      for (var item in allMessages.data!.values) {
        final message = RevaniMessage.fromJson(item.value);

        if (message.selfDestructTimestamp != null &&
            message.selfDestructTimestamp!.isBefore(now) &&
            !message.isDeleted) {
          await deleteMessage(
            messageId: message.messageId,
            userId: message.senderId,
            deleteForEveryone: true,
          );
        }
      }

      return ZeytinResponse(
        isSuccess: true,
        message: "Self-destruct messages processed",
      );
    } catch (e) {
      return ZeytinResponse(isSuccess: false, message: e.toString());
    }
  }

  Future<ZeytinUserResponse?> _getUserResponse(String userId) async {
    try {
      final userData = await zeytin.getData(box: "users", tag: userId);
      if (userData.data == null) return null;
      return ZeytinUserResponse.fromJson(userData.data!);
    } catch (e) {
      return null;
    }
  }

  Future<void> _updateChatLastMessage(
    String chatId,
    RevaniMessage message,
  ) async {
    try {
      final chatData = await zeytin.getData(box: "chats", tag: chatId);
      if (chatData.data != null) return;

      var chat = Chat.fromJson(chatData.data!);

      chat = chat.copyWith(
        lastMessage: message.text,
        lastMessageTimestamp: message.timestamp,
        lastMessageSenderID: message.senderId,
      );

      await zeytin.addData(box: "chats", tag: chatId, value: chat.toJson());
    } catch (e) {
      ZeytinPrint.errorPrint("Error updating chat last message: $e");
    }
  }

  String _getSystemMessageText(
    String type,
    String? userName,
    String? oldValue,
    String? value,
  ) {
    switch (type) {
      case 'user_joined':
        return '$userName joined the chat';
      case 'user_left':
        return '$userName left the chat';
      case 'group_created':
        return 'Group created by $userName';
      case 'name_changed':
        return '$userName changed group name from "$oldValue" to "$value"';
      case 'photo_changed':
        return '$userName changed group photo';
      case 'admin_added':
        return '$userName is now an admin';
      case 'admin_removed':
        return '$userName is no longer an admin';
      default:
        return 'System message';
    }
  }
}

class ZeytinUserResponse {
  final String username;
  final String uid;
  final String email;
  final String emailVerified;
  final String password;
  final String role;
  final String firstName;
  final String lastName;
  final String displayName;
  final String avatarUrl;
  final String gender;
  final String dateOfBirth;
  final String biography;
  final String preferredLanguage;
  final String timezone;
  final String accountStatus;
  final String accountUpdated;
  final String accountCreation;
  final String accountType;
  final String lastLoginTimestamp;
  final String lastLoginIp;
  final String socialMedias;
  final String theme;
  final String street;
  final String city;
  final String postalCode;
  final String country;
  final String locale;
  final String posts;
  final String createdBy;
  final String updatedBy;
  final String version;
  final Map<String, dynamic> data;

  ZeytinUserResponse({
    required this.username,
    required this.uid,
    required this.email,
    required this.emailVerified,
    required this.password,
    required this.role,
    required this.firstName,
    required this.lastName,
    required this.displayName,
    required this.avatarUrl,
    required this.gender,
    required this.dateOfBirth,
    required this.biography,
    required this.preferredLanguage,
    required this.timezone,
    required this.accountStatus,
    required this.accountUpdated,
    required this.accountCreation,
    required this.accountType,
    required this.lastLoginTimestamp,
    required this.lastLoginIp,
    required this.socialMedias,
    required this.theme,
    required this.street,
    required this.city,
    required this.postalCode,
    required this.country,
    required this.locale,
    required this.posts,
    required this.createdBy,
    required this.updatedBy,
    required this.version,
    required this.data,
  });

  factory ZeytinUserResponse.empty() {
    return ZeytinUserResponse(
      username: '',
      uid: '',
      email: '',
      emailVerified: '',
      password: '',
      role: '',
      firstName: '',
      lastName: '',
      displayName: '',
      avatarUrl: '',
      gender: '',
      dateOfBirth: '',
      biography: '',
      preferredLanguage: '',
      timezone: '',
      accountStatus: '',
      accountUpdated: '',
      accountCreation: '',
      accountType: '',
      lastLoginTimestamp: '',
      lastLoginIp: '',
      socialMedias: '',
      theme: '',
      street: '',
      city: '',
      postalCode: '',
      country: '',
      locale: '',
      posts: '',
      createdBy: '',
      updatedBy: '',
      version: '',
      data: {},
    );
  }

  factory ZeytinUserResponse.fromJson(Map<String, dynamic> json) {
    String s(dynamic v) {
      if (v == null) return '';
      return v.toString();
    }

    return ZeytinUserResponse(
      username: s(json['username']),
      uid: s(json['uid']),
      email: s(json['email']),
      emailVerified: s(json['email_verified']),
      password: s(json['password']),
      role: s(json['role']),
      firstName: s(json['first_name']),
      lastName: s(json['last_name']),
      displayName: s(json['display_name']),
      avatarUrl: s(json['avatar_url']),
      gender: s(json['gender']),
      dateOfBirth: s(json['date_of_birth']),
      biography: s(json['biography']),
      preferredLanguage: s(json['preferred_language']),
      timezone: s(json['timezone']),
      accountStatus: s(json['account_status']),
      accountUpdated: s(json['account_updated']),
      accountCreation: s(json['account_creation']),
      accountType: s(json['account_type']),
      lastLoginTimestamp: s(json['last_login_timestamp']),
      lastLoginIp: s(json['last_login_ip']),
      socialMedias: s(json['social_medias']),
      theme: s(json['theme']),
      street: s(json['street']),
      city: s(json['city']),
      postalCode: s(json['postal_code']),
      country: s(json['country']),
      locale: s(json['locale']),
      posts: s(json['posts']),
      createdBy: s(json['created_by']),
      updatedBy: s(json['updated_by']),
      version: s(json['version']),
      data: json['data'] is Map ? Map<String, dynamic>.from(json['data']) : {},
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'username': username,
      'uid': uid,
      'email': email,
      'email_verified': emailVerified,
      'password': password,
      'role': role,
      'first_name': firstName,
      'last_name': lastName,
      'display_name': displayName,
      'avatar_url': avatarUrl,
      'gender': gender,
      'date_of_birth': dateOfBirth,
      'biography': biography,
      'preferred_language': preferredLanguage,
      'timezone': timezone,
      'account_status': accountStatus,
      'account_updated': accountUpdated,
      'account_creation': accountCreation,
      'account_type': accountType,
      'last_login_timestamp': lastLoginTimestamp,
      'last_login_ip': lastLoginIp,
      'social_medias': socialMedias,
      'theme': theme,
      'street': street,
      'city': city,
      'postal_code': postalCode,
      'country': country,
      'locale': locale,
      'posts': posts,
      'created_by': createdBy,
      'updated_by': updatedBy,
      'version': version,
      'data': data,
    };
  }

  ZeytinUserResponse copyWith({
    String? username,
    String? uid,
    String? email,
    String? emailVerified,
    String? password,
    String? role,
    String? firstName,
    String? lastName,
    String? displayName,
    String? avatarUrl,
    String? gender,
    String? dateOfBirth,
    String? biography,
    String? preferredLanguage,
    String? timezone,
    String? accountStatus,
    String? accountUpdated,
    String? accountCreation,
    String? accountType,
    String? lastLoginTimestamp,
    String? lastLoginIp,
    String? socialMedias,
    String? theme,
    String? street,
    String? city,
    String? postalCode,
    String? country,
    String? locale,
    String? posts,
    String? createdBy,
    String? updatedBy,
    String? version,
    Map<String, dynamic>? data,
  }) {
    return ZeytinUserResponse(
      uid: uid ?? this.uid,
      username: username ?? this.username,
      email: email ?? this.email,
      emailVerified: emailVerified ?? this.emailVerified,
      password: password ?? this.password,
      role: role ?? this.role,
      firstName: firstName ?? this.firstName,
      lastName: lastName ?? this.lastName,
      displayName: displayName ?? this.displayName,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      gender: gender ?? this.gender,
      dateOfBirth: dateOfBirth ?? this.dateOfBirth,
      biography: biography ?? this.biography,
      preferredLanguage: preferredLanguage ?? this.preferredLanguage,
      timezone: timezone ?? this.timezone,
      accountStatus: accountStatus ?? this.accountStatus,
      accountUpdated: accountUpdated ?? this.accountUpdated,
      accountCreation: accountCreation ?? this.accountCreation,
      accountType: accountType ?? this.accountType,
      lastLoginTimestamp: lastLoginTimestamp ?? this.lastLoginTimestamp,
      lastLoginIp: lastLoginIp ?? this.lastLoginIp,
      socialMedias: socialMedias ?? this.socialMedias,
      theme: theme ?? this.theme,
      street: street ?? this.street,
      city: city ?? this.city,
      postalCode: postalCode ?? this.postalCode,
      country: country ?? this.country,
      locale: locale ?? this.locale,
      posts: posts ?? this.posts,
      createdBy: createdBy ?? this.createdBy,
      updatedBy: updatedBy ?? this.updatedBy,
      version: version ?? this.version,
      data: data != null
          ? Map<String, dynamic>.from(data)
          : Map<String, dynamic>.from(this.data),
    );
  }
}

class Chat {
  final List<ZeytinUserResponse>? participants;
  final String? chatID;
  final String? chatName;
  final String? chatPhotoURL;
  final String? lastMessage;
  final DateTime? lastMessageTimestamp;
  final String? lastMessageSenderID;
  final int unreadCount;
  final bool isMuted;
  final String type;
  final DateTime? createdAt;
  final List<String>? adminIDs;
  final Map<String, dynamic>? themeSettings;
  final List<String>? pinnedMessageIDs;
  final bool isArchived;
  final bool isBlocked;
  final List<String>? typingUserIDs;
  final String? disappearingMessagesTimer;
  final Map<String, dynamic>? callHistorySummary;
  final List<String>? botIDs;
  final Map<String, dynamic>? moreData;

  Chat({
    this.participants,
    this.chatID,
    this.chatName,
    this.chatPhotoURL,
    this.lastMessage,
    this.lastMessageTimestamp,
    this.lastMessageSenderID,
    this.unreadCount = 0,
    this.isMuted = false,
    this.type = "private",
    this.createdAt,
    this.adminIDs,
    this.themeSettings,
    this.pinnedMessageIDs,
    this.isArchived = false,
    this.isBlocked = false,
    this.typingUserIDs,
    this.disappearingMessagesTimer,
    this.callHistorySummary,
    this.botIDs,
    this.moreData,
  });

  Map<String, dynamic> toJson() {
    var participantList = [];
    if (participants != null) {
      for (var element in participants!) {
        participantList.add(element.toJson());
      }
    }

    return {
      "participants": participantList,
      "chatID": chatID ?? "",
      "chatName": chatName,
      "chatPhotoURL": chatPhotoURL,
      "lastMessage": lastMessage,
      "lastMessageTimestamp": lastMessageTimestamp?.toIso8601String(),
      "lastMessageSenderID": lastMessageSenderID,
      "unreadCount": unreadCount,
      "isMuted": isMuted,
      "type": type,
      "createdAt": createdAt?.toIso8601String(),
      "adminIDs": adminIDs ?? [],
      "themeSettings": themeSettings ?? {},
      "pinnedMessageIDs": pinnedMessageIDs ?? [],
      "isArchived": isArchived,
      "isBlocked": isBlocked,
      "typingUserIDs": typingUserIDs ?? [],
      "disappearingMessagesTimer": disappearingMessagesTimer,
      "callHistorySummary": callHistorySummary ?? {},
      "botIDs": botIDs ?? [],
      "moreData": moreData ?? {},
    };
  }

  Chat copyWith({
    List<ZeytinUserResponse>? participants,
    String? chatID,
    String? chatName,
    String? chatPhotoURL,
    String? lastMessage,
    DateTime? lastMessageTimestamp,
    String? lastMessageSenderID,
    int? unreadCount,
    bool? isMuted,
    String? type,
    DateTime? createdAt,
    List<String>? adminIDs,
    Map<String, dynamic>? themeSettings,
    List<String>? pinnedMessageIDs,
    bool? isArchived,
    bool? isBlocked,
    List<String>? typingUserIDs,
    String? disappearingMessagesTimer,
    Map<String, dynamic>? callHistorySummary,
    List<String>? botIDs,
    Map<String, dynamic>? moreData,
  }) {
    return Chat(
      participants: participants ?? this.participants,
      chatID: chatID ?? this.chatID,
      chatName: chatName ?? this.chatName,
      chatPhotoURL: chatPhotoURL ?? this.chatPhotoURL,
      lastMessage: lastMessage ?? this.lastMessage,
      lastMessageTimestamp: lastMessageTimestamp ?? this.lastMessageTimestamp,
      lastMessageSenderID: lastMessageSenderID ?? this.lastMessageSenderID,
      unreadCount: unreadCount ?? this.unreadCount,
      isMuted: isMuted ?? this.isMuted,
      type: type ?? this.type,
      createdAt: createdAt ?? this.createdAt,
      adminIDs: adminIDs ?? this.adminIDs,
      themeSettings: themeSettings ?? this.themeSettings,
      pinnedMessageIDs: pinnedMessageIDs ?? this.pinnedMessageIDs,
      isArchived: isArchived ?? this.isArchived,
      isBlocked: isBlocked ?? this.isBlocked,
      typingUserIDs: typingUserIDs ?? this.typingUserIDs,
      disappearingMessagesTimer:
          disappearingMessagesTimer ?? this.disappearingMessagesTimer,
      callHistorySummary: callHistorySummary ?? this.callHistorySummary,
      botIDs: botIDs ?? this.botIDs,
      moreData: moreData ?? this.moreData,
    );
  }

  factory Chat.fromJson(Map<String, dynamic> data) {
    List<ZeytinUserResponse> participantList = [];
    if (data["participants"] != null) {
      for (var element in data["participants"]!) {
        participantList.add(ZeytinUserResponse.fromJson(element));
      }
    }

    return Chat(
      participants: participantList,
      chatID: data["chatID"] ?? "",
      chatName: data["chatName"],
      chatPhotoURL: data["chatPhotoURL"],
      lastMessage: data["lastMessage"],
      lastMessageTimestamp: data["lastMessageTimestamp"] != null
          ? DateTime.tryParse(data["lastMessageTimestamp"])
          : null,
      lastMessageSenderID: data["lastMessageSenderID"],
      unreadCount: data["unreadCount"] ?? 0,
      isMuted: data["isMuted"] ?? false,
      type: data["type"] ?? "private",
      createdAt: data["createdAt"] != null
          ? DateTime.tryParse(data["createdAt"])
          : null,
      adminIDs: data["adminIDs"] != null
          ? List<String>.from(data["adminIDs"])
          : null,
      themeSettings: data["themeSettings"] != null
          ? Map<String, dynamic>.from(data["themeSettings"])
          : null,
      pinnedMessageIDs: data["pinnedMessageIDs"] != null
          ? List<String>.from(data["pinnedMessageIDs"])
          : null,
      isArchived: data["isArchived"] ?? false,
      isBlocked: data["isBlocked"] ?? false,
      typingUserIDs: data["typingUserIDs"] != null
          ? List<String>.from(data["typingUserIDs"])
          : null,
      disappearingMessagesTimer: data["disappearingMessagesTimer"],
      callHistorySummary: data["callHistorySummary"] != null
          ? Map<String, dynamic>.from(data["callHistorySummary"])
          : null,
      botIDs: data["botIDs"] != null ? List<String>.from(data["botIDs"]) : null,
      moreData: data["moreData"] != null
          ? Map<String, dynamic>.from(data["moreData"])
          : null,
    );
  }
}

class RevaniMediaDimensions {
  final int width;
  final int height;

  RevaniMediaDimensions({required this.width, required this.height});

  Map<String, dynamic> toJson() => {'width': width, 'height': height};
  factory RevaniMediaDimensions.fromJson(Map<String, dynamic> json) {
    return RevaniMediaDimensions(
      width: json['width'] ?? 0,
      height: json['height'] ?? 0,
    );
  }
}

class RevaniMedia {
  final String url;
  final String? thumbnailUrl;
  final int? fileSize;
  final String fileName;
  final String mimeType;
  final Duration? duration;
  final RevaniMediaDimensions? dimensions;

  RevaniMedia({
    required this.url,
    this.thumbnailUrl,
    this.fileSize,
    required this.fileName,
    required this.mimeType,
    this.duration,
    this.dimensions,
  });

  Map<String, dynamic> toJson() {
    return {
      'url': url,
      'thumbnailUrl': thumbnailUrl,
      'fileSize': fileSize,
      'fileName': fileName,
      'mimeType': mimeType,
      'duration': duration?.inMilliseconds,
      'dimensions': dimensions?.toJson(),
    };
  }

  factory RevaniMedia.fromJson(Map<String, dynamic> json) {
    return RevaniMedia(
      url: json['url'] ?? '',
      thumbnailUrl: json['thumbnailUrl'],
      fileSize: json['fileSize'],
      fileName: json['fileName'] ?? '',
      mimeType: json['mimeType'] ?? '',
      duration: json['duration'] != null
          ? Duration(milliseconds: json['duration'])
          : null,
      dimensions: json['dimensions'] != null
          ? RevaniMediaDimensions.fromJson(json['dimensions'])
          : null,
    );
  }
}

class RevaniLocation {
  final double latitude;
  final double longitude;
  final String? name;
  final String? address;

  RevaniLocation({
    required this.latitude,
    required this.longitude,
    this.name,
    this.address,
  });

  Map<String, dynamic> toJson() {
    return {
      'latitude': latitude,
      'longitude': longitude,
      'name': name,
      'address': address,
    };
  }

  factory RevaniLocation.fromJson(Map<String, dynamic> json) {
    return RevaniLocation(
      latitude: json['latitude'] ?? 0.0,
      longitude: json['longitude'] ?? 0.0,
      name: json['name'],
      address: json['address'],
    );
  }
}

class RevaniContact {
  final String name;
  final String? phoneNumber;
  final String? email;

  RevaniContact({required this.name, this.phoneNumber, this.email});

  Map<String, dynamic> toJson() {
    return {'name': name, 'phoneNumber': phoneNumber, 'email': email};
  }

  factory RevaniContact.fromJson(Map<String, dynamic> json) {
    return RevaniContact(
      name: json['name'] ?? '',
      phoneNumber: json['phoneNumber'],
      email: json['email'],
    );
  }
}

class RevaniReaction {
  final String emoji;
  final String userId;
  final DateTime timestamp;

  RevaniReaction({
    required this.emoji,
    required this.userId,
    required this.timestamp,
  });

  Map<String, dynamic> toJson() {
    return {
      'emoji': emoji,
      'userId': userId,
      'timestamp': timestamp.toIso8601String(),
    };
  }

  factory RevaniReaction.fromJson(Map<String, dynamic> json) {
    return RevaniReaction(
      emoji: json['emoji'] ?? '',
      userId: json['userId'] ?? '',
      timestamp: DateTime.parse(json['timestamp']),
    );
  }
}

class RevaniMessageReactions {
  final Map<String, List<RevaniReaction>> reactions;

  RevaniMessageReactions({Map<String, List<RevaniReaction>>? reactions})
    : reactions = reactions ?? {};

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> result = {};
    reactions.forEach((emoji, reactionList) {
      result[emoji] = reactionList.map((r) => r.toJson()).toList();
    });
    return result;
  }

  factory RevaniMessageReactions.fromJson(Map<String, dynamic> json) {
    final Map<String, List<RevaniReaction>> reactionsMap = {};

    json.forEach((emoji, reactionData) {
      if (reactionData is List) {
        reactionsMap[emoji] = reactionData
            .map<RevaniReaction>((item) => RevaniReaction.fromJson(item))
            .toList();
      }
    });

    return RevaniMessageReactions(reactions: reactionsMap);
  }
}

class RevaniMessageStatusInfo {
  final List<String> deliveredTo;
  final List<String> readBy;
  final DateTime? deliveredAt;
  final DateTime? readAt;

  RevaniMessageStatusInfo({
    List<String>? deliveredTo,
    List<String>? readBy,
    this.deliveredAt,
    this.readAt,
  }) : deliveredTo = deliveredTo ?? [],
       readBy = readBy ?? [];

  Map<String, dynamic> toJson() {
    return {
      'deliveredTo': deliveredTo,
      'readBy': readBy,
      'deliveredAt': deliveredAt?.toIso8601String(),
      'readAt': readAt?.toIso8601String(),
    };
  }

  RevaniMessageStatusInfo copyWith({
    List<String>? deliveredTo,
    List<String>? readBy,
    DateTime? deliveredAt,
    DateTime? readAt,
  }) {
    return RevaniMessageStatusInfo(
      deliveredTo: deliveredTo ?? this.deliveredTo,
      readBy: readBy ?? this.readBy,
      deliveredAt: deliveredAt ?? this.deliveredAt,
      readAt: readAt ?? this.readAt,
    );
  }

  factory RevaniMessageStatusInfo.fromJson(Map<String, dynamic> json) {
    return RevaniMessageStatusInfo(
      deliveredTo: json['deliveredTo'] != null
          ? List<String>.from(json['deliveredTo'])
          : [],
      readBy: json['readBy'] != null ? List<String>.from(json['readBy']) : [],
      deliveredAt: json['deliveredAt'] != null
          ? DateTime.tryParse(json['deliveredAt'])
          : null,
      readAt: json['readAt'] != null ? DateTime.tryParse(json['readAt']) : null,
    );
  }
}

class RevaniSystemMessageData {
  final String type;
  final String? userId;
  final String? userName;
  final String? oldValue;
  final String? value;

  RevaniSystemMessageData({
    required this.type,
    this.userId,
    this.userName,
    this.oldValue,
    this.value,
  });

  Map<String, dynamic> toJson() {
    return {
      'type': type,
      'userId': userId,
      'userName': userName,
      'oldValue': oldValue,
      'value': value,
    };
  }

  factory RevaniSystemMessageData.fromJson(Map<String, dynamic> json) {
    return RevaniSystemMessageData(
      type: json['type'] ?? '',
      userId: json['userId'],
      userName: json['userName'],
      oldValue: json['oldValue'],
      value: json['value'],
    );
  }
}

class RevaniInteractiveButton {
  final String id;
  final String text;
  final String type;
  final String? payload;

  RevaniInteractiveButton({
    required this.id,
    required this.text,
    required this.type,
    this.payload,
  });

  Map<String, dynamic> toJson() {
    return {'id': id, 'text': text, 'type': type, 'payload': payload};
  }

  factory RevaniInteractiveButton.fromJson(Map<String, dynamic> json) {
    return RevaniInteractiveButton(
      id: json['id'] ?? '',
      text: json['text'] ?? '',
      type: json['type'] ?? '',
      payload: json['payload'],
    );
  }
}

class RevaniMessage {
  final String messageId;
  final String chatId;
  final String senderId;
  final String text;
  final DateTime timestamp;
  final String messageType;
  final String status;
  final bool isEdited;
  final DateTime? editedTimestamp;
  final bool isDeleted;
  final bool deletedForEveryone;
  final bool isForwarded;
  final String? forwardedFrom;
  final RevaniMedia? media;
  final RevaniLocation? location;
  final RevaniContact? contact;
  final String? replyToMessageId;
  final List<String> mentions;
  final RevaniMessageReactions reactions;
  final RevaniMessageStatusInfo statusInfo;
  final List<String> starredBy;
  final bool isPinned;
  final String? pinnedBy;
  final DateTime? pinnedTimestamp;
  final bool isSystemMessage;
  final RevaniSystemMessageData? systemMessageData;
  final bool encrypted;
  final String? encryptionKey;
  final Duration? selfDestructTimer;
  final DateTime? selfDestructTimestamp;
  final String? localId;
  final String? serverId;
  final int sequenceNumber;
  final String? botId;
  final List<RevaniInteractiveButton> interactiveButtons;
  final Map<String, dynamic> metadata;

  RevaniMessage({
    required this.messageId,
    required this.chatId,
    required this.senderId,
    required this.text,
    required this.timestamp,
    this.messageType = 'text',
    this.status = 'sent',
    this.isEdited = false,
    this.editedTimestamp,
    this.isDeleted = false,
    this.deletedForEveryone = false,
    this.isForwarded = false,
    this.forwardedFrom,
    this.media,
    this.location,
    this.contact,
    this.replyToMessageId,
    List<String>? mentions,
    RevaniMessageReactions? reactions,
    RevaniMessageStatusInfo? statusInfo,
    List<String>? starredBy,
    this.isPinned = false,
    this.pinnedBy,
    this.pinnedTimestamp,
    this.isSystemMessage = false,
    this.systemMessageData,
    this.encrypted = false,
    this.encryptionKey,
    this.selfDestructTimer,
    this.selfDestructTimestamp,
    this.localId,
    this.serverId,
    this.sequenceNumber = 0,
    this.botId,
    List<RevaniInteractiveButton>? interactiveButtons,
    Map<String, dynamic>? metadata,
  }) : mentions = mentions ?? [],
       reactions = reactions ?? RevaniMessageReactions(),
       statusInfo = statusInfo ?? RevaniMessageStatusInfo(),
       starredBy = starredBy ?? [],
       interactiveButtons = interactiveButtons ?? [],
       metadata = metadata ?? {};

  Map<String, dynamic> toJson() {
    return {
      'messageId': messageId,
      'chatId': chatId,
      'senderId': senderId,
      'text': text,
      'timestamp': timestamp.toIso8601String(),
      'messageType': messageType,
      'status': status,
      'isEdited': isEdited,
      'editedTimestamp': editedTimestamp?.toIso8601String(),
      'isDeleted': isDeleted,
      'deletedForEveryone': deletedForEveryone,
      'isForwarded': isForwarded,
      'forwardedFrom': forwardedFrom,
      'media': media?.toJson(),
      'location': location?.toJson(),
      'contact': contact?.toJson(),
      'replyToMessageId': replyToMessageId,
      'mentions': mentions,
      'reactions': reactions.toJson(),
      'statusInfo': statusInfo.toJson(),
      'starredBy': starredBy,
      'isPinned': isPinned,
      'pinnedBy': pinnedBy,
      'pinnedTimestamp': pinnedTimestamp?.toIso8601String(),
      'isSystemMessage': isSystemMessage,
      'systemMessageData': systemMessageData?.toJson(),
      'encrypted': encrypted,
      'encryptionKey': encryptionKey,
      'selfDestructTimer': selfDestructTimer?.inSeconds,
      'selfDestructTimestamp': selfDestructTimestamp?.toIso8601String(),
      'localId': localId,
      'serverId': serverId,
      'sequenceNumber': sequenceNumber,
      'botId': botId,
      'interactiveButtons': interactiveButtons.map((b) => b.toJson()).toList(),
      'metadata': metadata,
    };
  }

  factory RevaniMessage.fromJson(Map<String, dynamic> json) {
    return RevaniMessage(
      messageId: json['messageId'] ?? '',
      chatId: json['chatId'] ?? '',
      senderId: json['senderId'] ?? '',
      text: json['text'] ?? '',
      timestamp: DateTime.parse(json['timestamp']),
      messageType: json['messageType'] ?? 'text',
      status: json['status'] ?? 'sent',
      isEdited: json['isEdited'] ?? false,
      editedTimestamp: json['editedTimestamp'] != null
          ? DateTime.tryParse(json['editedTimestamp'])
          : null,
      isDeleted: json['isDeleted'] ?? false,
      deletedForEveryone: json['deletedForEveryone'] ?? false,
      isForwarded: json['isForwarded'] ?? false,
      forwardedFrom: json['forwardedFrom'],
      media: json['media'] != null ? RevaniMedia.fromJson(json['media']) : null,
      location: json['location'] != null
          ? RevaniLocation.fromJson(json['location'])
          : null,
      contact: json['contact'] != null
          ? RevaniContact.fromJson(json['contact'])
          : null,
      replyToMessageId: json['replyToMessageId'],
      mentions: json['mentions'] != null
          ? List<String>.from(json['mentions'])
          : [],
      reactions: json['reactions'] != null
          ? RevaniMessageReactions.fromJson(json['reactions'])
          : RevaniMessageReactions(),
      statusInfo: json['statusInfo'] != null
          ? RevaniMessageStatusInfo.fromJson(json['statusInfo'])
          : RevaniMessageStatusInfo(),
      starredBy: json['starredBy'] != null
          ? List<String>.from(json['starredBy'])
          : [],
      isPinned: json['isPinned'] ?? false,
      pinnedBy: json['pinnedBy'],
      pinnedTimestamp: json['pinnedTimestamp'] != null
          ? DateTime.tryParse(json['pinnedTimestamp'])
          : null,
      isSystemMessage: json['isSystemMessage'] ?? false,
      systemMessageData: json['systemMessageData'] != null
          ? RevaniSystemMessageData.fromJson(json['systemMessageData'])
          : null,
      encrypted: json['encrypted'] ?? false,
      encryptionKey: json['encryptionKey'],
      selfDestructTimer: json['selfDestructTimer'] != null
          ? Duration(seconds: json['selfDestructTimer'])
          : null,
      selfDestructTimestamp: json['selfDestructTimestamp'] != null
          ? DateTime.tryParse(json['selfDestructTimestamp'])
          : null,
      localId: json['localId'],
      serverId: json['serverId'],
      sequenceNumber: json['sequenceNumber'] ?? 0,
      botId: json['botId'],
      interactiveButtons: json['interactiveButtons'] != null
          ? (json['interactiveButtons'] as List)
                .map((item) => RevaniInteractiveButton.fromJson(item))
                .toList()
          : [],
      metadata: json['metadata'] != null
          ? Map<String, dynamic>.from(json['metadata'])
          : {},
    );
  }

  RevaniMessage copyWith({
    String? messageId,
    String? chatId,
    String? senderId,
    String? text,
    DateTime? timestamp,
    String? messageType,
    String? status,
    bool? isEdited,
    DateTime? editedTimestamp,
    bool? isDeleted,
    bool? deletedForEveryone,
    bool? isForwarded,
    String? forwardedFrom,
    RevaniMedia? media,
    RevaniLocation? location,
    RevaniContact? contact,
    String? replyToMessageId,
    List<String>? mentions,
    RevaniMessageReactions? reactions,
    RevaniMessageStatusInfo? statusInfo,
    List<String>? starredBy,
    bool? isPinned,
    String? pinnedBy,
    DateTime? pinnedTimestamp,
    bool? isSystemMessage,
    RevaniSystemMessageData? systemMessageData,
    bool? encrypted,
    String? encryptionKey,
    Duration? selfDestructTimer,
    DateTime? selfDestructTimestamp,
    String? localId,
    String? serverId,
    int? sequenceNumber,
    String? botId,
    List<RevaniInteractiveButton>? interactiveButtons,
    Map<String, dynamic>? metadata,
  }) {
    return RevaniMessage(
      messageId: messageId ?? this.messageId,
      chatId: chatId ?? this.chatId,
      senderId: senderId ?? this.senderId,
      text: text ?? this.text,
      timestamp: timestamp ?? this.timestamp,
      messageType: messageType ?? this.messageType,
      status: status ?? this.status,
      isEdited: isEdited ?? this.isEdited,
      editedTimestamp: editedTimestamp ?? this.editedTimestamp,
      isDeleted: isDeleted ?? this.isDeleted,
      deletedForEveryone: deletedForEveryone ?? this.deletedForEveryone,
      isForwarded: isForwarded ?? this.isForwarded,
      forwardedFrom: forwardedFrom ?? this.forwardedFrom,
      media: media ?? this.media,
      location: location ?? this.location,
      contact: contact ?? this.contact,
      replyToMessageId: replyToMessageId ?? this.replyToMessageId,
      mentions: mentions ?? this.mentions,
      reactions: reactions ?? this.reactions,
      statusInfo: statusInfo ?? this.statusInfo,
      starredBy: starredBy ?? this.starredBy,
      isPinned: isPinned ?? this.isPinned,
      pinnedBy: pinnedBy ?? this.pinnedBy,
      pinnedTimestamp: pinnedTimestamp ?? this.pinnedTimestamp,
      isSystemMessage: isSystemMessage ?? this.isSystemMessage,
      systemMessageData: systemMessageData ?? this.systemMessageData,
      encrypted: encrypted ?? this.encrypted,
      encryptionKey: encryptionKey ?? this.encryptionKey,
      selfDestructTimer: selfDestructTimer ?? this.selfDestructTimer,
      selfDestructTimestamp:
          selfDestructTimestamp ?? this.selfDestructTimestamp,
      localId: localId ?? this.localId,
      serverId: serverId ?? this.serverId,
      sequenceNumber: sequenceNumber ?? this.sequenceNumber,
      botId: botId ?? this.botId,
      interactiveButtons: interactiveButtons ?? this.interactiveButtons,
      metadata: metadata ?? this.metadata,
    );
  }
}


============================================================
FILE: lib/config.dart
============================================================

class ZeytinConfig {
  static const int maxTruckCount = 20;
  static const int maxTruckPerIp = 20;
  static const int truckCreationCooldownMs = 600000;
  static const int globalDosThreshold = 50000;
  static const int dosCooldownMs = 300000;
  static const int ipRateLimitMs = 1000;
  static const int generalIpRateLimit5Sec = 100;
  static bool sleepModeEnabled = true;
  static List<String> blackList = [];
  static List<String> whiteList = ["127.0.0.1"];
  static String liveKitUrl = "ws://127.0.0.1:7880";
  static String liveKitApiKey = "devkey";
  static String liveKitSecretKey = "secret";
}


============================================================
FILE: lib/html/hello_world.dart
============================================================

String helloWorldHTML = """
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Zeytin🫒</title>
          <style>
              body {
                  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                  background-color: #f9fafb;
                  color: #1f2937;
                  display: flex;
                  justify-content: center;
                  align-items: center;
                  height: 100vh;
                  margin: 0;
              }
              .container {
                  text-align: center;
                  background: white;
                  padding: 3rem;
                  border-radius: 1rem;
                  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
                  max-width: 400px;
                  width: 90%;
              }
              h1 {
                  font-size: 2.5rem;
                  margin-bottom: 0.5rem;
                  color: #d97706;
              }
              .tagline {
                  font-size: 1.1rem;
                  color: #4b5563;
                  margin-bottom: 2rem;
              }
              .status {
                  display: inline-flex;
                  align-items: center;
                  background-color: #d1fae5;
                  color: #065f46;
                  padding: 0.5rem 1rem;
                  border-radius: 9999px;
                  font-weight: 600;
                  font-size: 0.875rem;
              }
              .dot {
                  height: 8px;
                  width: 8px;
                  background-color: #059669;
                  border-radius: 50%;
                  margin-right: 0.5rem;
              }
              .footer {
                  margin-top: 2rem;
                  font-size: 0.75rem;
                  color: #9ca3af;
              }
          </style>
      </head>
      <body>
          <div class="container">
              <h1>Zeytin🫒</h1>
              <p class="tagline">Developed for humanity by <strong>JeaFriday</strong></p>
              <div class="status">
                  <span class="dot"></span>
                  All Systems Operational
              </div>
              <p class="footer">Serving delicious data since 2026</p>
          </div>
      </body>
      </html>
""";

============================================================
FILE: lib/logic/account.dart
============================================================

import 'dart:convert';
import 'dart:io';
import 'package:crypto/crypto.dart';
import 'package:uuid/uuid.dart';
import 'package:zeytin/logic/engine.dart';
import 'package:zeytin/models/response.dart';

class ZeytinAccounts {
  static String _generateHash(String password, String salt) {
    final bytes = utf8.encode(password + salt);
    return sha256.convert(bytes).toString();
  }

  static Future<bool> isEmailRegistered(Zeytin zeytin, String email) async {
    final results = await zeytin.filter(
      "system",
      "trucks",
      (data) => data["email"] == email,
    );
    return results.isNotEmpty;
  }

  static Future<ZeytinResponse> createAccount(
    Zeytin zeytin,
    String email,
    String password,
  ) async {
    
    if (await isEmailRegistered(zeytin, email)) {
      return ZeytinResponse(
        isSuccess: false,
        message: "Opss...",
        error: "This email has been used before.",
      );
    }

    String truckID = const Uuid().v1();
    String hashedPassword = _generateHash(password, truckID);

    await zeytin.put(
      truckId: "system",
      boxId: "trucks",
      tag: truckID,
      value: {
        "email": email,
        "password": hashedPassword,
        "id": truckID,
        "createdAt": DateTime.now().toIso8601String(),
      },
    );
    await Directory(
      "${zeytin.rootPath}/$truckID/storage",
    ).create(recursive: true);
    await zeytin.createTruck(truckId: truckID);
    return ZeytinResponse(
      isSuccess: true,
      message: "Oki doki!",
      data: {"id": truckID},
    );
  }

  static Future<ZeytinResponse> login(
    Zeytin zeytin,
    String email,
    String password,
  ) async {
    final results = await zeytin.filter(
      "system",
      "trucks",
      (data) => data["email"] == email,
    );

    if (results.isNotEmpty) {
      String truckID = results.first["id"];
      String storedHash = results.first["password"];
      String loginHash = _generateHash(password, truckID);

      if (storedHash == loginHash) {
        return ZeytinResponse(
          isSuccess: true,
          message: "Oki doki!",
          data: {"id": truckID},
        );
      }
    }
    return ZeytinResponse(
      isSuccess: false,
      message: "Opss...",
      error: "The email or password doesn't match.",
    );
  }
}


============================================================
FILE: lib/logic/engine.dart
============================================================

import 'dart:io';
import 'dart:convert';
import 'dart:typed_data';
import 'dart:async';
import 'dart:isolate';

class LRUCache<K, V> {
  final int maxSize;
  final Map<K, _Node<V>> _map = {};
  _Node<V>? _head;
  _Node<V>? _tail;
  int _size = 0;

  LRUCache(this.maxSize);

  V? get(K key) {
    final node = _map[key];
    if (node == null) return null;
    _moveToHead(node);
    return node.value;
  }

  void put(K key, V value) {
    if (_map.containsKey(key)) {
      final node = _map[key]!;
      node.value = value;
      _moveToHead(node);
    } else {
      final node = _Node<V>(key, value);
      _map[key] = node;
      _addToHead(node);
      _size++;
      if (_size > maxSize) {
        _removeTail();
      }
    }
  }

  bool contains(K key) => _map.containsKey(key);

  void remove(K key) {
    final node = _map[key];
    if (node != null) {
      _removeNode(node);
      _map.remove(key);
      _size--;
    }
  }

  void clear() {
    _map.clear();
    _head = _tail = null;
    _size = 0;
  }

  void _moveToHead(_Node<V> node) {
    if (node == _head) return;
    _removeNode(node);
    _addToHead(node);
  }

  void _addToHead(_Node<V> node) {
    node.prev = null;
    node.next = _head;
    if (_head != null) _head!.prev = node;
    _head = node;
    _tail ??= node;
  }

  void _removeNode(_Node<V> node) {
    if (node.prev != null) {
      node.prev!.next = node.next;
    } else {
      _head = node.next;
    }
    if (node.next != null) {
      node.next!.prev = node.prev;
    } else {
      _tail = node.prev;
    }
    node.prev = null;
    node.next = null;
  }

  void _removeTail() {
    if (_tail != null) {
      final key = _tail!.key;
      _removeNode(_tail!);
      _map.remove(key);
      _size--;
    }
  }
}

class _Node<V> {
  final dynamic key;
  V value;
  _Node<V>? prev;
  _Node<V>? next;
  _Node(this.key, this.value);
}

class BinaryEncoder {
  static const int typeNULL = 0;
  static const int typeBOOL = 1;
  static const int typeINT = 2;
  static const int typeDOUBLE = 3;
  static const int typeSTRING = 4;
  static const int typeLIST = 5;
  static const int typeMAP = 6;
  static const int magicByte = 0xDB;

  static Uint8List encode(String boxId, String tag, Map<String, dynamic> data) {
    final builder = BytesBuilder();
    builder.addByte(magicByte);
    final boxBytes = utf8.encode(boxId);
    _encodeRawLength(builder, boxBytes.length);
    builder.add(boxBytes);
    final tagBytes = utf8.encode(tag);
    _encodeRawLength(builder, tagBytes.length);
    builder.add(tagBytes);
    final dataBytes = _encodeMap(data);
    _encodeRawLength(builder, dataBytes.length);
    builder.add(dataBytes);
    return builder.toBytes();
  }

  static Uint8List _encodeMap(Map<String, dynamic> data) {
    final builder = BytesBuilder();
    _encodeValue(builder, data);
    return builder.toBytes();
  }

  static Map<String, dynamic> decodeValue(Uint8List bytes) {
    final reader = ByteData.view(bytes.buffer);
    return _decodeValue(reader, 0).value as Map<String, dynamic>;
  }

  static void _encodeValue(BytesBuilder builder, dynamic value) {
    if (value == null) {
      builder.addByte(typeNULL);
    } else if (value is bool) {
      builder.addByte(typeBOOL);
      builder.addByte(value ? 1 : 0);
    } else if (value is int) {
      builder.addByte(typeINT);
      final bytes = ByteData(8);
      bytes.setInt64(0, value, Endian.little);
      builder.add(bytes.buffer.asUint8List());
    } else if (value is double) {
      builder.addByte(typeDOUBLE);
      final bytes = ByteData(8);
      bytes.setFloat64(0, value, Endian.little);
      builder.add(bytes.buffer.asUint8List());
    } else if (value is String) {
      builder.addByte(typeSTRING);
      final utf8Bytes = utf8.encode(value);
      _encodeRawLength(builder, utf8Bytes.length);
      builder.add(utf8Bytes);
    } else if (value is List) {
      builder.addByte(typeLIST);
      _encodeRawLength(builder, value.length);
      for (var item in value) {
        _encodeValue(builder, item);
      }
    } else if (value is Map<String, dynamic>) {
      builder.addByte(typeMAP);
      _encodeRawLength(builder, value.length);
      for (var entry in value.entries) {
        _encodeValue(builder, entry.key);
        _encodeValue(builder, entry.value);
      }
    } else {
      throw ArgumentError('Unsupported type: ${value.runtimeType}');
    }
  }

  static MapEntry<int, dynamic> _decodeValue(ByteData reader, int offset) {
    final type = reader.getUint8(offset++);
    switch (type) {
      case typeNULL:
        return MapEntry(offset, null);
      case typeBOOL:
        return MapEntry(offset + 1, reader.getUint8(offset) == 1);
      case typeINT:
        return MapEntry(offset + 8, reader.getInt64(offset, Endian.little));
      case typeDOUBLE:
        return MapEntry(offset + 8, reader.getFloat64(offset, Endian.little));
      case typeSTRING:
        final len = reader.getUint32(offset, Endian.little);
        offset += 4;
        final val = utf8.decode(
          Uint8List.view(reader.buffer, reader.offsetInBytes + offset, len),
        );
        return MapEntry(offset + len, val);
      case typeLIST:
        final len = reader.getUint32(offset, Endian.little);
        offset += 4;
        final list = [];
        for (var i = 0; i < len; i++) {
          final res = _decodeValue(reader, offset);
          offset = res.key;
          list.add(res.value);
        }
        return MapEntry(offset, list);
      case typeMAP:
        final len = reader.getUint32(offset, Endian.little);
        offset += 4;
        final map = <String, dynamic>{};
        for (var i = 0; i < len; i++) {
          final kRes = _decodeValue(reader, offset);
          final vRes = _decodeValue(reader, kRes.key);
          offset = vRes.key;
          map[kRes.value as String] = vRes.value;
        }
        return MapEntry(offset, map);
      default:
        throw FormatException('Unknown type: $type');
    }
  }

  static void _encodeRawLength(BytesBuilder builder, int length) {
    final bytes = ByteData(4);
    bytes.setUint32(0, length, Endian.little);
    builder.add(bytes.buffer.asUint8List());
  }
}

class PersistentIndex {
  final File _file;
  Map<String, Map<String, List<int>>> _index = {};

  PersistentIndex(String path) : _file = File(path);

  Future<void> load() async {
    if (await _file.exists()) {
      final bytes = await _file.readAsBytes();
      if (bytes.isNotEmpty) _index = _deserializeIndex(bytes);
    }
  }

  Future<void> save() async {
    final bytes = _serializeIndex(_index);
    await _file.writeAsBytes(bytes);
  }

  void update(String boxId, String tag, int offset, int length) {
    _index[boxId] ??= {};
    _index[boxId]![tag] = [offset, length];
  }

  List<int>? get(String boxId, String tag) => _index[boxId]?[tag];
  Map<String, List<int>>? getBox(String boxId) => _index[boxId];

  int getLastOffset() {
    int maxOffset = 0;
    for (var box in _index.values) {
      for (var addr in box.values) {
        if (addr[0] + addr[1] > maxOffset) maxOffset = addr[0] + addr[1];
      }
    }
    return maxOffset;
  }

  Uint8List _serializeIndex(Map<String, Map<String, List<int>>> index) {
    final builder = BytesBuilder();
    final boxIds = index.keys.toList();
    final bCount = ByteData(4)..setUint32(0, boxIds.length, Endian.little);
    builder.add(bCount.buffer.asUint8List());
    for (var bId in boxIds) {
      final bBytes = utf8.encode(bId);
      builder.add(
        (ByteData(
          4,
        )..setUint32(0, bBytes.length, Endian.little)).buffer.asUint8List(),
      );
      builder.add(bBytes);
      final tags = index[bId]!;
      builder.add(
        (ByteData(
          4,
        )..setUint32(0, tags.length, Endian.little)).buffer.asUint8List(),
      );
      for (var entry in tags.entries) {
        final tBytes = utf8.encode(entry.key);
        builder.add(
          (ByteData(
            4,
          )..setUint32(0, tBytes.length, Endian.little)).buffer.asUint8List(),
        );
        builder.add(tBytes);
        final addr = ByteData(8);
        addr.setUint32(0, entry.value[0], Endian.little);
        addr.setUint32(4, entry.value[1], Endian.little);
        builder.add(addr.buffer.asUint8List());
      }
    }
    return builder.toBytes();
  }

  Map<String, Map<String, List<int>>> _deserializeIndex(Uint8List bytes) {
    final res = <String, Map<String, List<int>>>{};
    final reader = ByteData.view(bytes.buffer);
    int offset = 0;
    if (bytes.length < 4) return res;
    final bCount = reader.getUint32(offset, Endian.little);
    offset += 4;
    for (var i = 0; i < bCount; i++) {
      final bLen = reader.getUint32(offset, Endian.little);
      offset += 4;
      final bId = utf8.decode(
        Uint8List.view(reader.buffer, reader.offsetInBytes + offset, bLen),
      );
      offset += bLen;
      final tCount = reader.getUint32(offset, Endian.little);
      offset += 4;
      final bMap = <String, List<int>>{};
      for (var j = 0; j < tCount; j++) {
        final tLen = reader.getUint32(offset, Endian.little);
        offset += 4;
        final t = utf8.decode(
          Uint8List.view(reader.buffer, reader.offsetInBytes + offset, tLen),
        );
        offset += tLen;
        final aOff = reader.getUint32(offset, Endian.little);
        offset += 4;
        final aLen = reader.getUint32(offset, Endian.little);
        offset += 4;
        bMap[t] = [aOff, aLen];
      }
      res[bId] = bMap;
    }
    return res;
  }
}

class Truck {
  final String id;
  final String path;
  final PersistentIndex _index;
  final LRUCache<String, Map<String, dynamic>> _cache;
  final Map<String, Map<String, dynamic>> _hotCache = {};
  final Map<String, Map<String, Map<String, Set<String>>>> _fieldIndex = {};
  int _compactCounter = 0;
  final int _compactThreshold = 500;
  bool _isCompacting = false;
  RandomAccessFile? _reader;
  RandomAccessFile? _writer;
  Future<void> _lock = Future.value();
  int _dirtyCount = 0;
  final int _saveThreshold = 500;
  bool _isSavingIndex = false;

  Truck(this.id, this.path)
    : _index = PersistentIndex('$path/$id.idx'),
      _cache = LRUCache(10000);

  File get _dataFile => File('$path/$id.dat');

  Future<void> initialize() async {
    await _index.load();
    if (await _dataFile.exists()) {
      await _repair();
      _writer = await _dataFile.open(mode: FileMode.append);
      await _rebuildSearchIndex();
    }
  }

  Future<T> _synchronized<T>(Future<T> Function() action) async {
    await _lock;
    final completer = Completer<T>();
    // ignore: body_might_complete_normally_catch_error
    _lock = completer.future.catchError((_) {});
    try {
      final result = await action();
      completer.complete(result);
      return result;
    } catch (e) {
      completer.completeError(e);
      rethrow;
    }
  }

  Future<Map<String, dynamic>?> _readInternal(String bId, String t) async {
    final key = '$bId:$t';
    if (_hotCache.containsKey(key)) return _hotCache[key];
    final c = _cache.get(key);
    if (c != null) {
      _updateHot(key, c);
      return c;
    }
    final addr = _index.get(bId, t);
    if (addr == null) return null;
    _reader ??= await _dataFile.open(mode: FileMode.read);

    await _reader!.setPosition(addr[0]);
    final block = await _reader!.read(addr[1]);
    final blockReader = ByteData.view(block.buffer);
    int offset = 1;
    final boxIdLen = blockReader.getUint32(offset, Endian.little);
    offset += 4 + boxIdLen;
    final tagLen = blockReader.getUint32(offset, Endian.little);
    offset += 4 + tagLen;
    final dataLen = blockReader.getUint32(offset, Endian.little);
    offset += 4;
    final dataBytes = block.sublist(offset, offset + dataLen);
    try {
      final data = BinaryEncoder.decodeValue(dataBytes);
      _cache.put(key, data);
      _updateHot(key, data);
      return data;
    } catch (e) {
      return null;
    }
  }

  Future<void> _rebuildSearchIndex() async {
    final boxes = _index._index.keys;
    for (var bId in boxes) {
      final boxData = _index.getBox(bId);
      if (boxData == null) continue;
      for (var tag in boxData.keys) {
        final data = await read(bId, tag);
        if (data != null) {
          _updateInternalIndex(bId, tag, data);
        }
      }
    }
  }

  void _updateInternalIndex(String bId, String tag, Map<String, dynamic> data) {
    data.forEach((field, value) {
      if (value is String) {
        _fieldIndex[bId] ??= {};
        _fieldIndex[bId]![field] ??= {};
        _fieldIndex[bId]![field]![value] ??= {};
        _fieldIndex[bId]![field]![value]!.add(tag);
      }
    });
  }

  Future<List<Map<String, dynamic>>> queryAdvanced({
    required String bId,
    bool Function(Map<String, dynamic>)? filter,
  }) async {
    final List<Map<String, dynamic>> results = [];
    final boxData = _index.getBox(bId);
    if (boxData == null) return results;
    for (var tag in boxData.keys) {
      final data = await read(bId, tag);
      if (data != null) {
        if (filter == null || filter(data)) {
          results.add(data);
        }
      }
    }
    return results;
  }

  Future<List<Map<String, dynamic>>> query(
    String bId,
    String field,
    String prefix,
  ) async {
    final List<Map<String, dynamic>> results = [];
    final boxIdx = _fieldIndex[bId];
    if (boxIdx == null) return results;
    final fieldIdx = boxIdx[field];
    if (fieldIdx == null) return results;
    for (var entry in fieldIdx.entries) {
      if (entry.key.startsWith(prefix)) {
        for (var tag in entry.value) {
          final data = await read(bId, tag);
          if (data != null) results.add(data);
        }
      }
    }
    return results;
  }

  Future<void> _repair() async {
    final int last = _index.getLastOffset();
    final int actual = await _dataFile.length();
    if (actual > last) {
      final raf = await _dataFile.open(mode: FileMode.read);
      await raf.setPosition(last);
      int pos = last;
      while (pos < actual) {
        try {
          final magic = await raf.readByte();
          if (magic != BinaryEncoder.magicByte) break;
          final bLenBytes = await raf.read(4);
          final bLen = ByteData.view(
            bLenBytes.buffer,
          ).getUint32(0, Endian.little);
          final boxIdBytes = await raf.read(bLen);
          final boxId = utf8.decode(boxIdBytes);
          final tLenBytes = await raf.read(4);
          final tLen = ByteData.view(
            tLenBytes.buffer,
          ).getUint32(0, Endian.little);
          final tagBytes = await raf.read(tLen);
          final tag = utf8.decode(tagBytes);
          final dLenBytes = await raf.read(4);
          final dLen = ByteData.view(
            dLenBytes.buffer,
          ).getUint32(0, Endian.little);
          final dataBytes = await raf.read(dLen);
          final data = BinaryEncoder.decodeValue(dataBytes);
          final total = (await raf.position()) - pos;
          _index.update(boxId, tag, pos, total);
          _updateInternalIndex(boxId, tag, data);
          pos = await raf.position();
        } catch (_) {
          break;
        }
      }
      await raf.close();
      await _index.save();
    }
  }

  Future<void> write(String bId, String t, Map<String, dynamic> v) {
    return _synchronized(() async {
      _writer ??= await _dataFile.open(mode: FileMode.append);
      final off = await _writer!.length();
      final bytes = BinaryEncoder.encode(bId, t, v);
      await _writer!.writeFrom(bytes);
      await _writer!.flush();
      _index.update(bId, t, off, bytes.length);
      _updateInternalIndex(bId, t, v);
      _dirtyCount++;
      _compactCounter++;
      if (_dirtyCount >= _saveThreshold && !_isSavingIndex) _autoSave();
      if (_compactCounter >= _compactThreshold && !_isCompacting) {
        _runAutoCompact();
      }
      final key = '$bId:$t';
      _cache.put(key, v);
      _updateHot(key, v);
    });
  }

  Future<void> batch(String bId, Map<String, Map<String, dynamic>> entries) {
    return _synchronized(() async {
      _writer ??= await _dataFile.open(mode: FileMode.append);
      var off = await _writer!.length();
      for (var entry in entries.entries) {
        final bytes = BinaryEncoder.encode(bId, entry.key, entry.value);
        await _writer!.writeFrom(bytes);
        _index.update(bId, entry.key, off, bytes.length);
        _updateInternalIndex(bId, entry.key, entry.value);
        final key = '$bId:${entry.key}';
        _cache.put(key, entry.value);
        _updateHot(key, entry.value);
        off += bytes.length;
        _dirtyCount++;
        _compactCounter++;
      }
      await _writer!.flush();
      if (_dirtyCount >= _saveThreshold && !_isSavingIndex) _autoSave();
      if (_compactCounter >= _compactThreshold && !_isCompacting) {
        _runAutoCompact();
      }
    });
  }

  void _runAutoCompact() {
    _isCompacting = true;
    _compactCounter = 0;
    compact()
        .then((_) {
          _isCompacting = false;
        })
        .catchError((e) {
          _isCompacting = false;
        });
  }

  void _autoSave() {
    _isSavingIndex = true;
    _dirtyCount = 0;
    // ignore: body_might_complete_normally_catch_error
    _index.save().then((_) => _isSavingIndex = false).catchError((_) {
      _isSavingIndex = false;
    });
  }

  Future<Map<String, dynamic>?> read(String bId, String t) {
    return _synchronized(() async {
      return await _readInternal(bId, t);
    });
  }

  Future<Map<String, Map<String, dynamic>>> readBox(String bId) {
    return _synchronized(() async {
      final res = <String, Map<String, dynamic>>{};
      final box = _index.getBox(bId);
      if (box == null) return res;
      for (var t in box.keys) {
        final data = await _readInternal(bId, t);
        if (data != null) {
          res[t] = data;
        }
      }
      return res;
    });
  }

  void _updateHot(String k, Map<String, dynamic> v) {
    if (_hotCache.length >= 100) _hotCache.remove(_hotCache.keys.first);
    _hotCache[k] = v;
  }

  Future<void> compact() {
    return _synchronized(() async {
      final tempFile = File('$path/${id}_temp.dat');
      final IOSink sink = tempFile.openWrite();
      final newIndex = PersistentIndex('$path/${id}_temp.idx');
      int currentOffset = 0;
      final boxes = _index._index.keys.toList();
      for (var bId in boxes) {
        final tags = _index._index[bId]?.keys.toList() ?? [];
        for (var tag in tags) {
          final data = await _readInternal(bId, tag);
          if (data != null) {
            final bytes = BinaryEncoder.encode(bId, tag, data);
            sink.add(bytes);
            newIndex.update(bId, tag, currentOffset, bytes.length);
            currentOffset += bytes.length;
          }
        }
      }
      await sink.flush();
      await sink.close();
      await _reader?.close();
      await _writer?.close();
      _reader = null;
      _writer = null;
      final oldDataFile = _dataFile;
      final oldIdxFile = File(_index._file.path);
      if (await oldDataFile.exists()) await oldDataFile.delete();
      if (await oldIdxFile.exists()) await oldIdxFile.delete();
      await tempFile.rename(oldDataFile.path);
      await File(newIndex._file.path).rename(oldIdxFile.path);
      _index._index = newIndex._index;
      await _index.save();
      _writer = await _dataFile.open(mode: FileMode.append);
    });
  }

  Future<void> close() async {
    await _index.save();
    await _reader?.close();
    await _writer?.close();
  }
}

class TruckIsolate {
  late Truck _truck;

  Future<void> init(String id, String path) async {
    _truck = Truck(id, path);
    await _truck.initialize();
  }

  Future<void> write(
    String boxId,
    String tag,
    Map<String, dynamic> value,
  ) async {
    await _truck.write(boxId, tag, value);
  }

  Future<Map<String, dynamic>?> read(String boxId, String tag) async {
    return await _truck.read(boxId, tag);
  }

  Future<void> batch(
    String boxId,
    Map<String, Map<String, dynamic>> entries,
  ) async {
    await _truck.batch(boxId, entries);
  }

  Future<Map<String, Map<String, dynamic>>> readBox(String boxId) async {
    return await _truck.readBox(boxId);
  }

  Future<List<Map<String, dynamic>>> query(
    String boxId,
    String field,
    String prefix,
  ) async {
    return await _truck.query(boxId, field, prefix);
  }

  Future<List<Map<String, dynamic>>> queryAdvanced({
    required String boxId,
    bool Function(Map<String, dynamic>)? filter,
  }) async {
    return await _truck.queryAdvanced(bId: boxId, filter: filter);
  }

  Future<void> compact() async {
    await _truck.compact();
  }

  Future<void> close() async {
    await _truck.close();
  }

  Future<void> removeTag(String boxId, String tag) async {
    _truck._index._index[boxId]?.remove(tag);
    _truck._cache.remove('$boxId:$tag');
    await _truck._index.save();
  }

  Future<bool> contains(String boxId, String tag) async {
    return await _truck.read(boxId, tag) != null;
  }
}

class TruckProxy {
  final String id;
  final String path;
  late SendPort _sendPort;
  final Map<int, Completer<dynamic>> _completers = {};
  int _messageId = 0;
  final ReceivePort _receivePort = ReceivePort();

  TruckProxy(this.id, this.path);

  Future<void> initialize() async {
    await Isolate.spawn(_startTruckIsolate, _receivePort.sendPort);
    final completer = Completer<void>();
    _receivePort.listen((message) {
      if (message is SendPort) {
        _sendPort = message;
        _sendCommand('init', {'id': id, 'path': path}).then((_) {
          completer.complete();
        });
      } else if (message is Map) {
        final id = message['id'] as int;
        final completer = _completers[id];
        if (completer != null) {
          if (message.containsKey('result')) {
            completer.complete(message['result']);
          } else if (message.containsKey('error')) {
            completer.completeError(Exception(message['error']));
          }
          _completers.remove(id);
        }
      }
    });
    await completer.future;
  }

  Future<void> removeTag(String boxId, String tag) async {
    return await _sendCommand('removeTag', {'boxId': boxId, 'tag': tag});
  }

  static void _startTruckIsolate(SendPort sendPort) {
    final receivePort = ReceivePort();
    sendPort.send(receivePort.sendPort);
    final truckIsolate = TruckIsolate();
    receivePort.listen((message) async {
      if (message is Map) {
        final command = message['command'] as String;
        final params = message['params'] as Map<String, dynamic>;
        final id = message['id'] as int;
        try {
          dynamic result;
          switch (command) {
            case 'init':
              await truckIsolate.init(
                params['id'] as String,
                params['path'] as String,
              );
              result = null;
              break;
            case 'write':
              await truckIsolate.write(
                params['boxId'] as String,
                params['tag'] as String,
                params['value'] as Map<String, dynamic>,
              );
              result = null;
              break;
            case 'read':
              result = await truckIsolate.read(
                params['boxId'] as String,
                params['tag'] as String,
              );
              break;
            case 'batch':
              await truckIsolate.batch(
                params['boxId'] as String,
                params['entries'] as Map<String, Map<String, dynamic>>,
              );
              result = null;
              break;
            case 'readBox':
              result = await truckIsolate.readBox(params['boxId'] as String);
              break;
            case 'query':
              result = await truckIsolate.query(
                params['boxId'] as String,
                params['field'] as String,
                params['prefix'] as String,
              );
              break;
            case 'queryAdvanced':
              result = await truckIsolate.queryAdvanced(
                boxId: params['boxId'] as String,
                filter:
                    params['filter'] as bool Function(Map<String, dynamic>)?,
              );
              break;
            case 'removeTag':
              await truckIsolate.removeTag(
                params['boxId'] as String,
                params['tag'] as String,
              );
              result = null;
              break;
            case 'compact':
              await truckIsolate.compact();
              result = null;
              break;
            case 'close':
              await truckIsolate.close();
              result = null;
              break;
            case 'contains':
              result = await truckIsolate.contains(
                params['boxId'] as String,
                params['tag'] as String,
              );
              break;
            default:
              throw Exception('Unknown command: $command');
          }
          sendPort.send({'id': id, 'result': result});
        } catch (e) {
          sendPort.send({'id': id, 'error': e.toString()});
        }
      }
    });
  }

  Future<dynamic> _sendCommand(String command, Map<String, dynamic> params) {
    final id = _messageId++;
    final completer = Completer<dynamic>();
    _completers[id] = completer;
    _sendPort.send({'command': command, 'params': params, 'id': id});
    return completer.future;
  }

  Future<void> write(
    String boxId,
    String tag,
    Map<String, dynamic> value,
  ) async {
    return await _sendCommand('write', {
      'boxId': boxId,
      'tag': tag,
      'value': value,
    });
  }

  Future<Map<String, dynamic>?> read(String boxId, String tag) async {
    return await _sendCommand('read', {'boxId': boxId, 'tag': tag});
  }

  Future<void> batch(
    String boxId,
    Map<String, Map<String, dynamic>> entries,
  ) async {
    return await _sendCommand('batch', {'boxId': boxId, 'entries': entries});
  }

  Future<Map<String, Map<String, dynamic>>> readBox(String boxId) async {
    return await _sendCommand('readBox', {'boxId': boxId});
  }

  Future<List<Map<String, dynamic>>> query(
    String boxId,
    String field,
    String prefix,
  ) async {
    return await _sendCommand('query', {
      'boxId': boxId,
      'field': field,
      'prefix': prefix,
    });
  }

  Future<List<Map<String, dynamic>>> queryAdvanced({
    required String boxId,
    bool Function(Map<String, dynamic>)? filter,
  }) async {
    final boxData = await readBox(boxId);
    final results = <Map<String, dynamic>>[];
    for (var entry in boxData.values) {
      if (filter == null || filter(entry)) {
        results.add(entry);
      }
    }
    return results;
  }

  Future<void> compact() async {
    return await _sendCommand('compact', {});
  }

  Future<void> close() async {
    return await _sendCommand('close', {});
  }

  Future<bool> contains(String boxId, String tag) async {
    return await _sendCommand('contains', {'boxId': boxId, 'tag': tag});
  }
}

class Zeytin {
  final String rootPath;
  final LRUCache<String, Map<String, dynamic>> _memoryCache;
  final Map<String, TruckProxy> _activeTrucks = {};

  Zeytin(this.rootPath, {int cacheSize = 50000})
    : _memoryCache = LRUCache(cacheSize) {
    Directory(rootPath).createSync(recursive: true);
  }
  final StreamController<Map<String, dynamic>> _changeController =
      StreamController<Map<String, dynamic>>.broadcast();
  Stream<Map<String, dynamic>> get changes => _changeController.stream;
  Future<TruckProxy> _resolveTruck({required String truckId}) async {
    if (_activeTrucks.containsKey(truckId)) {
      return _activeTrucks[truckId]!;
    }
    final truck = TruckProxy(truckId, rootPath);
    await truck.initialize();
    _activeTrucks[truckId] = truck;
    return truck;
  }

  String _generateCacheKey({
    required String truckId,
    required String boxId,
    required String tag,
  }) {
    return '$truckId:$boxId:$tag';
  }

  Future<void> delete({
    required String truckId,
    required String boxId,
    required String tag,
  }) async {
    final key = _generateCacheKey(truckId: truckId, boxId: boxId, tag: tag);
    final truck = await _resolveTruck(truckId: truckId);
    await truck.removeTag(boxId, tag);
    _memoryCache.remove(key);
    _changeController.add({
      "truckId": truckId,
      "boxId": boxId,
      "tag": tag,
      "op": "DELETE",
    });
  }

  Future<void> deleteBox({
    required String truckId,
    required String boxId,
  }) async {
    final truck = await _resolveTruck(truckId: truckId);
    final boxData = await truck.readBox(boxId);
    for (var tag in boxData.keys) {
      final key = _generateCacheKey(truckId: truckId, boxId: boxId, tag: tag);
      _memoryCache.remove(key);
    }
    _changeController.add({
      "truckId": truckId,
      "boxId": boxId,
      "op": "DELETE_BOX",
    });
  }

  Future<void> deleteTruck({required String truckId}) async {
    if (_activeTrucks.containsKey(truckId)) {
      await _activeTrucks[truckId]!.close();
      _activeTrucks.remove(truckId);
    }
    final dataFile = File('$rootPath/$truckId.dat');
    final indexFile = File('$rootPath/$truckId.idx');
    if (await dataFile.exists()) await dataFile.delete();
    if (await indexFile.exists()) await indexFile.delete();
  }

  List<String> getAllTruck() {
    final dir = Directory(rootPath);
    return dir
        .listSync()
        .where((entity) => entity is File && entity.path.endsWith('.dat'))
        .map(
          (entity) => entity.path
              .split(Platform.pathSeparator)
              .last
              .replaceAll('.dat', ''),
        )
        .toList();
  }

  Map<String, TruckProxy> getAllBox() {
    return Map.unmodifiable(_activeTrucks);
  }

  Future<void> deleteAll() async {
    for (var truck in _activeTrucks.values) {
      await truck.close();
    }
    _activeTrucks.clear();
    _memoryCache.clear();
    final dir = Directory(rootPath);
    if (await dir.exists()) {
      await dir.delete(recursive: true);
      await dir.create(recursive: true);
    }
  }

  Future<void> put({
    required String truckId,
    required String boxId,
    required String tag,
    required Map<String, dynamic> value,
  }) async {
    bool isUpdate = await existsTag(truckId: truckId, boxId: boxId, tag: tag);

    final truck = await _resolveTruck(truckId: truckId);
    await truck.write(boxId, tag, value);

    _memoryCache.put(
      _generateCacheKey(truckId: truckId, boxId: boxId, tag: tag),
      value,
    );
    _changeController.add({
      "truckId": truckId,
      "boxId": boxId,
      "tag": tag,
      "op": isUpdate ? "UPDATE" : "PUT",
      "value": value,
    });
  }

  Future<void> putBatch({
    required String truckId,
    required String boxId,
    required Map<String, Map<String, dynamic>> entries,
  }) async {
    final truck = await _resolveTruck(truckId: truckId);
    await truck.batch(boxId, entries);
    for (var entry in entries.entries) {
      _memoryCache.put(
        _generateCacheKey(truckId: truckId, boxId: boxId, tag: entry.key),
        entry.value,
      );
    }
    _changeController.add({
      "truckId": truckId,
      "boxId": boxId,
      "op": "BATCH",
      "entries": entries,
    });
  }

  Future<Map<String, dynamic>?> get({
    required String truckId,
    required String boxId,
    required String tag,
  }) async {
    final cacheKey = _generateCacheKey(
      truckId: truckId,
      boxId: boxId,
      tag: tag,
    );
    final cachedValue = _memoryCache.get(cacheKey);
    if (cachedValue != null) return cachedValue;
    final truck = await _resolveTruck(truckId: truckId);
    final data = await truck.read(boxId, tag);
    if (data != null) {
      _memoryCache.put(cacheKey, data);
    }
    return data;
  }

  Future<Map<String, Map<String, dynamic>>> getBox({
    required String truckId,
    required String boxId,
  }) async {
    final truck = await _resolveTruck(truckId: truckId);
    final boxData = await truck.readBox(boxId);
    for (var entry in boxData.entries) {
      _memoryCache.put(
        _generateCacheKey(truckId: truckId, boxId: boxId, tag: entry.key),
        entry.value,
      );
    }
    return boxData;
  }

  Future<List<Map<String, dynamic>>> search(
    String truckId,
    String boxId,
    String field,
    String prefix,
  ) async {
    final truck = await _resolveTruck(truckId: truckId);
    return await truck.query(boxId, field, prefix);
  }

  Future<void> compactTruck({required String truckId}) async {
    if (_activeTrucks.containsKey(truckId)) {
      final truck = _activeTrucks[truckId]!;
      await truck.compact();
      _memoryCache.clear();
    }
  }

  Future<List<Map<String, dynamic>>> filter(
    String truckId,
    String boxId,
    bool Function(Map<String, dynamic>) predicate,
  ) async {
    final truck = await _resolveTruck(truckId: truckId);
    return await truck.queryAdvanced(boxId: boxId, filter: predicate);
  }

  Future<bool> contains(String truckId, String boxId, String tag) async {
    if (_memoryCache.contains(
      _generateCacheKey(truckId: truckId, boxId: boxId, tag: tag),
    )) {
      return true;
    }
    final truck = await _resolveTruck(truckId: truckId);
    final data = await truck.read(boxId, tag);
    return data != null;
  }

  Future<bool> existsTruck({required String truckId}) async {
    final dataFile = File('$rootPath/$truckId.dat');
    return await dataFile.exists();
  }

  Future<bool> existsBox({
    required String truckId,
    required String boxId,
  }) async {
    if (!await existsTruck(truckId: truckId)) return false;
    final truck = await _resolveTruck(truckId: truckId);
    final boxData = await truck.readBox(boxId);
    return boxData.isNotEmpty;
  }

  Future<bool> existsTag({
    required String truckId,
    required String boxId,
    required String tag,
  }) async {
    final cacheKey = _generateCacheKey(
      truckId: truckId,
      boxId: boxId,
      tag: tag,
    );
    if (_memoryCache.contains(cacheKey)) return true;
    if (!await existsTruck(truckId: truckId)) return false;
    final truck = await _resolveTruck(truckId: truckId);
    return await truck.contains(boxId, tag);
  }

  Future<void> createTruck({required String truckId}) async {
    if (await existsTruck(truckId: truckId)) return;
    final truck = TruckProxy(truckId, rootPath);
    await truck.initialize();
    _activeTrucks[truckId] = truck;
  }

  Future<void> close() async {
    for (var truck in _activeTrucks.values) {
      await truck.close();
    }
    _activeTrucks.clear();
    _memoryCache.clear();
  }
}


============================================================
FILE: lib/logic/gatekeeper.dart
============================================================

import 'dart:async';
import 'dart:convert';
import 'package:shelf/shelf.dart';
import 'package:zeytin/models/response.dart';
import 'package:zeytin/tools/ip.dart';
import '../config.dart';

class IpActivity {
  int lastTruckCreated = 0;
  int truckCount = 0;
  List<int> requestTimestamps = [];
  int lastTokenRequest = 0;
  bool isBanned = false;
}

class Gatekeeper {
  static Map<String, IpActivity> ipRegistry = {};
  static int globalRequestCount = 0;
  static int sleepModeUntil = 0;

  static Future<Response?> check(Request request) async {
    final now = DateTime.now().millisecondsSinceEpoch;

    if (ZeytinConfig.sleepModeEnabled && now < sleepModeUntil) {
      return Response(503, body: "Be quiet! I'm trying to sleep here.");
    }

    globalRequestCount++;
    if (globalRequestCount > ZeytinConfig.globalDosThreshold) {
      sleepModeUntil = now + ZeytinConfig.dosCooldownMs;
      globalRequestCount = 0;
      return Response(503, body: "Be quiet! I'm trying to sleep here.");
    }
    Timer(const Duration(seconds: 5), () => globalRequestCount = 0);

    final String ip = getClientIp(request);

    if (ZeytinConfig.blackList.contains(ip)) {
      return Response.forbidden(
        jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opss...",
            error: "I see I've banned your IP address. Get out!",
          ).toMap(),
        ),
      );
    }

    if (ZeytinConfig.whiteList.contains(ip)) {
      return null;
    }

    final activity = ipRegistry.putIfAbsent(ip, () => IpActivity());

    if (activity.isBanned) {
      return Response.forbidden(
        jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opss...",
            error: "I see I've banned your IP address. Get out!",
          ).toMap(),
        ),
      );
    }

    activity.requestTimestamps.add(now);
    activity.requestTimestamps.removeWhere((t) => now - t > 5000);

    if (activity.requestTimestamps.length >
        ZeytinConfig.generalIpRateLimit5Sec) {
      return Response(
        429,
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opss...",
            error: "Whoa, fast kid! Slow down, or...",
          ).toMap(),
        ),
      );
    }

    if (request.url.path == 'token/create') {
      if (now - activity.lastTokenRequest < ZeytinConfig.ipRateLimitMs) {
        return Response(
          429,
          body: jsonEncode(
            ZeytinResponse(
              isSuccess: false,
              message: "Opss...",
              error:
                  "I understand you need that token, but you need to slow down a bit. You can request it once every second.",
            ).toMap(),
          ),
        );
      }
      activity.lastTokenRequest = now;
    }

    return null;
  }
}


============================================================
FILE: lib/logic/live_engine.dart
============================================================

import 'package:dart_jsonwebtoken/dart_jsonwebtoken.dart';
import 'package:zeytin/config.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

class LiveEngine {
  static bool get isEnabled =>
      ZeytinConfig.liveKitUrl.isNotEmpty &&
      ZeytinConfig.liveKitApiKey.isNotEmpty;
  static String createToken({
    required String roomName,
    required String identity,
    required String name,
    bool isAdmin = false,
  }) {
    if (!isEnabled) {
      throw Exception("LiveKit is not configured on this server.");
    }

    final jwt = JWT({
      'sub': identity,
      'name': name,
      'video': {
        'room': roomName,
        'roomJoin': true,
        'canPublish': true,
        'canSubscribe': true,
        'canPublishData': true,
        'roomAdmin': isAdmin,
      },
    }, issuer: ZeytinConfig.liveKitApiKey);

    return jwt.sign(
      SecretKey(ZeytinConfig.liveKitSecretKey),
      expiresIn: Duration(hours: 6),
    );
  }

  static Future<bool> isRoomActive(String roomName) async {
    if (!isEnabled) return false;
    final jwt = JWT({
      'video': {
        'roomList': true,
        'roomRecord': false,
      },
    }, issuer: ZeytinConfig.liveKitApiKey);

    String adminToken = jwt.sign(
      SecretKey(ZeytinConfig.liveKitSecretKey),
      expiresIn: Duration(minutes: 1),
    );

    try {
      String baseUrl = ZeytinConfig.liveKitUrl;
      String httpUrl = baseUrl
          .replaceAll("ws://", "http://")
          .replaceAll("wss://", "https://");
      String targetUrl = "$httpUrl/twirp/livekit.RoomService/ListRooms";
      var response = await http.post(
        Uri.parse(targetUrl),
        headers: {
          "Authorization": "Bearer $adminToken",
          "Content-Type": "application/json",
        },
        body: jsonEncode({
          "names": [roomName],
        }),
      );

      if (response.statusCode == 200) {
        var body = jsonDecode(response.body);
        List rooms = body['rooms'] ?? [];
        if (rooms.isNotEmpty) {
          var room = rooms.first;
          int numParticipants = room['num_participants'] ?? 0;
          return numParticipants > 0;
        }
      }
      return false;
    } catch (e) {
      print("LiveKit API Hatası: $e");
      return false;
    }
  }
}


============================================================
FILE: lib/models/response.dart
============================================================

class ZeytinResponse {
  final bool isSuccess;
  final String message;
  final String? error;
  final Map<String, dynamic>? data;

  ZeytinResponse({
    required this.isSuccess,
    required this.message,
    this.error,
    this.data,
  });

  factory ZeytinResponse.fromMap(Map<String, dynamic> map) {
    return ZeytinResponse(
      isSuccess: map['isSuccess'] ?? false,
      message: map['message'] ?? '',
      error: map['error'],
      data: Map<String, dynamic>.from(map['data'] ?? {}),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      "isSuccess": isSuccess,
      "message": message,
      if (error != null) "error": error,
      if (data != null) "data": data,
    };
  }
}


============================================================
FILE: lib/routes/account.dart
============================================================

import 'dart:convert';
import 'package:shelf/shelf.dart';
import 'package:shelf_router/shelf_router.dart';
import 'package:zeytin/logic/account.dart';
import 'package:zeytin/logic/engine.dart';
import 'package:zeytin/logic/gatekeeper.dart';
import 'package:zeytin/models/response.dart';
import 'package:zeytin/config.dart';
import 'package:zeytin/tools/ip.dart';

void accountRoutes(Zeytin zeytin, Router router) {
  router.post('/truck/create', (Request request) async {
    final payload = await request.readAsString();
    final data = jsonDecode(payload);

    final String? email = data['email'];
    final String? password = data['password'];

    if (email == null || password == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opss...",
            error: "Email and password parameters are mandatory.",
          ).toMap(),
        ),
      );
    }
    final String ip = getClientIp(request);
    final activity = Gatekeeper.ipRegistry[ip];
    final now = DateTime.now().millisecondsSinceEpoch;

    if (activity != null) {
      if (activity.truckCount >= ZeytinConfig.maxTruckPerIp) {
        activity.isBanned = true;
        return Response.forbidden(
          jsonEncode(
            ZeytinResponse(
              isSuccess: false,
              message: "Opss...",
              error:
                  "You have reached the maximum truck limit for this IP. You are banned!",
            ).toMap(),
          ),
        );
      }
      if (now - activity.lastTruckCreated <
          ZeytinConfig.truckCreationCooldownMs) {
        return Response(
          429,
          body: jsonEncode(
            ZeytinResponse(
              isSuccess: false,
              message: "Opss...",
              error:
                  "You can only create one truck every 10 minutes. Slow down.",
            ).toMap(),
          ),
        );
      }
    }
    if (zeytin.getAllTruck().length >= ZeytinConfig.maxTruckCount) {
      return Response(
        507,
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opss...",
            error: "System storage is full. No more trucks can be created.",
          ).toMap(),
        ),
      );
    }

    ZeytinResponse zeytinResponse = await ZeytinAccounts.createAccount(
      zeytin,
      email,
      password,
    );

    if (zeytinResponse.isSuccess) {
      if (activity != null) {
        activity.lastTruckCreated = now;
        activity.truckCount++;
      }
      return Response.ok(jsonEncode(zeytinResponse.toMap()));
    } else {
      return Response.badRequest(body: jsonEncode(zeytinResponse.toMap()));
    }
  });

  router.post('/truck/id', (Request request) async {
    final payload = await request.readAsString();
    final data = jsonDecode(payload);

    final String? email = data['email'];
    final String? password = data['password'];

    if (email == null || password == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opss...",
            error: "Email and password parameters are mandatory.",
          ).toMap(),
        ),
      );
    }

    ZeytinResponse zeytinResponse = await ZeytinAccounts.login(
      zeytin,
      email,
      password,
    );

    if (zeytinResponse.isSuccess) {
      return Response.ok(jsonEncode(zeytinResponse.toMap()));
    } else {
      return Response.badRequest(body: jsonEncode(zeytinResponse.toMap()));
    }
  });
}


============================================================
FILE: lib/routes/call.dart
============================================================

import 'dart:async';
import 'dart:convert';
import 'package:shelf/shelf.dart';
import 'package:shelf_router/shelf_router.dart';
import 'package:shelf_web_socket/shelf_web_socket.dart';
import 'package:web_socket_channel/web_socket_channel.dart';
import 'package:zeytin/logic/engine.dart';
import 'package:zeytin/logic/live_engine.dart';
import 'package:zeytin/routes/token.dart';
import 'package:zeytin/tools/tokener.dart';
import 'package:zeytin/config.dart';
import 'package:uuid/uuid.dart';

void callRoutes(Zeytin zeytin, Router router) {
  router.post('/call/join', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];

    if (token == null || data == null) {
      return Response.badRequest(body: "Missing parameters");
    }

    var tokenData = getTokenData(token);
    if (tokenData == null || !isTokenValid(token)) {
      return Response.forbidden("Invalid token");
    }
    String password = tokenData["password"];

    try {
      var params = ZeytinTokener(password).decryptMap(data);
      String roomName = params["roomName"];
      String uid = params["uid"];
      String connectionIdentity = "$uid-${const Uuid().v4().substring(0, 6)}";

      String liveToken = LiveEngine.createToken(
        roomName: roomName,
        identity: connectionIdentity,
        name: "User-$uid",
        isAdmin: true,
      );

      final responseData = ZeytinTokener(
        password,
      ).encryptMap({"serverUrl": ZeytinConfig.liveKitUrl, "token": liveToken});

      return Response.ok(
        jsonEncode({
          "isSuccess": true,
          "message": "Ready to connect",
          "data": responseData,
        }),
      );
    } catch (e) {
      return Response.internalServerError(
        body: jsonEncode({"error": e.toString()}),
      );
    }
  });

  router.post('/call/check', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];

    if (token == null || data == null) {
      return Response.badRequest(body: "Missing parameters");
    }

    var tokenData = getTokenData(token);
    if (tokenData == null || !isTokenValid(token)) {
      return Response.forbidden("Invalid token");
    }
    String password = tokenData["password"];

    try {
      var params = ZeytinTokener(password).decryptMap(data);
      String roomName = params["roomName"];
      bool isActive = await LiveEngine.isRoomActive(roomName);

      final responseData = ZeytinTokener(
        password,
      ).encryptMap({"isActive": isActive});

      return Response.ok(
        jsonEncode({
          "isSuccess": true,
          "message": "Checked",
          "data": responseData,
        }),
      );
    } catch (e) {
      return Response.internalServerError(
        body: jsonEncode({"error": e.toString()}),
      );
    }
  });

  router.get('/call/stream/<token>', (Request request, String token) {
    return webSocketHandler((WebSocketChannel webSocket, a) {
      var tokenData = getTokenData(token);
      if (tokenData == null || !isTokenValid(token)) {
        webSocket.sink.add(jsonEncode({"error": "Unauthorized"}));
        webSocket.sink.close();
        return;
      }
      String password = tokenData["password"];

      String? encryptedData = request.url.queryParameters['data'];
      if (encryptedData == null) {
        webSocket.sink.add(jsonEncode({"error": "Missing data parameter"}));
        webSocket.sink.close();
        return;
      }

      String roomName;
      try {
        var params = ZeytinTokener(password).decryptMap(encryptedData);
        roomName = params["roomName"];
      } catch (e) {
        webSocket.sink.add(jsonEncode({"error": "Invalid data encryption"}));
        webSocket.sink.close();
        return;
      }

      bool? lastStatus;
      Timer? timer;

      LiveEngine.isRoomActive(roomName).then((isActive) {
        lastStatus = isActive;
        webSocket.sink.add(jsonEncode({"isActive": isActive}));
      });

      timer = Timer.periodic(Duration(seconds: 5), (_) async {
        bool currentStatus = await LiveEngine.isRoomActive(roomName);
        if (currentStatus != lastStatus) {
          lastStatus = currentStatus;
          webSocket.sink.add(jsonEncode({"isActive": currentStatus}));
        }
      });

      webSocket.stream.listen(
        (message) {},
        onDone: () {
          timer?.cancel();
        },
        onError: (error) {
          timer?.cancel();
        },
      );
    })(request);
  });
}


============================================================
FILE: lib/routes/crud.dart
============================================================

import 'dart:convert';

import 'package:shelf/shelf.dart';
import 'package:shelf_router/shelf_router.dart';
import 'package:zeytin/logic/engine.dart';
import 'package:zeytin/models/response.dart';
import 'package:zeytin/routes/token.dart';
import 'package:zeytin/tools/tokener.dart';

void crudRoutes(Zeytin zeytin, Router router) {
  router.post('/data/add', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null ||
        dataDecrypted["tag"] == null ||
        dataDecrypted["value"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box, tag and value parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      if (dataDecrypted["value"] is Map) {
        await zeytin.put(
          truckId: truck,
          boxId: dataDecrypted["box"],
          tag: dataDecrypted["tag"],
          value: dataDecrypted["value"],
        );
        return Response.ok(
          jsonEncode(
            ZeytinResponse(isSuccess: true, message: "Oki doki!").toMap(),
          ),
        );
      } else {
        return Response.badRequest(
          body: jsonEncode(
            ZeytinResponse(
              isSuccess: false,
              message: "Opps...",
              error:
                  "The Value parameter must be of type Map<String, dynamic>.",
            ).toMap(),
          ),
        );
      }
    }
  });

  router.post('/data/get', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null || dataDecrypted["tag"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box and tag parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      var getData = await zeytin.get(
        truckId: truck,
        boxId: dataDecrypted["box"],
        tag: dataDecrypted["tag"],
      );
      if (getData == null) {
        return Response.badRequest(
          body: jsonEncode(
            ZeytinResponse(
              isSuccess: false,
              message: "Opps...",
              error: "This box does not contain any such data.",
            ).toMap(),
          ),
        );
      }
      final encryptedData = ZeytinTokener(password).encryptMap(getData);
      return Response.ok(
        jsonEncode({
          "isSuccess": true,
          "message": "Oki doki!",
          "data": encryptedData,
        }),
      );
    }
  });

  router.post('/data/delete', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null || dataDecrypted["tag"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box and tag parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      await zeytin.delete(
        truckId: truck,
        boxId: dataDecrypted["box"],
        tag: dataDecrypted["tag"],
      );
      return Response.ok(
        jsonEncode(
          ZeytinResponse(isSuccess: true, message: "Oki doki!").toMap(),
        ),
      );
    }
  });

  router.post('/data/deleteBox', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box parameter is mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      await zeytin.deleteBox(truckId: truck, boxId: dataDecrypted["box"]);
      return Response.ok(
        jsonEncode(
          ZeytinResponse(isSuccess: true, message: "Oki doki!").toMap(),
        ),
      );
    }
  });

  router.post('/data/addBatch', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null || dataDecrypted["entries"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box and entries parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      if (dataDecrypted["entries"] is Map) {
        Map<String, Map<String, dynamic>> entries = {};
        (dataDecrypted["entries"] as Map).forEach((key, value) {
          if (value is Map<String, dynamic>) {
            entries[key.toString()] = value;
          }
        });

        await zeytin.putBatch(
          truckId: truck,
          boxId: dataDecrypted["box"],
          entries: entries,
        );
        return Response.ok(
          jsonEncode(
            ZeytinResponse(isSuccess: true, message: "Oki doki!").toMap(),
          ),
        );
      } else {
        return Response.badRequest(
          body: jsonEncode(
            ZeytinResponse(
              isSuccess: false,
              message: "Opps...",
              error:
                  "The Entries parameter must be of type Map<String, Map<String, dynamic>>.",
            ).toMap(),
          ),
        );
      }
    }
  });

  router.post('/data/getBox', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box parameter is mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      var boxData = await zeytin.getBox(
        truckId: truck,
        boxId: dataDecrypted["box"],
      );
      final encryptedData = ZeytinTokener(password).encryptMap(boxData);
      return Response.ok(
        jsonEncode({
          "isSuccess": true,
          "message": "Oki doki!",
          "data": encryptedData,
        }),
      );
    }
  });

  router.post('/data/existsBox', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box parameter is mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      bool exists = await zeytin.existsBox(
        truckId: truck,
        boxId: dataDecrypted["box"],
      );
      final encryptedData = ZeytinTokener(
        password,
      ).encryptMap({"exists": exists});
      return Response.ok(
        jsonEncode({
          "isSuccess": true,
          "message": "Oki doki!",
          "data": encryptedData,
        }),
      );
    }
  });

  router.post('/data/existsTag', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null || dataDecrypted["tag"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box and tag parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      bool exists = await zeytin.existsTag(
        truckId: truck,
        boxId: dataDecrypted["box"],
        tag: dataDecrypted["tag"],
      );
      final encryptedData = ZeytinTokener(
        password,
      ).encryptMap({"exists": exists});
      return Response.ok(
        jsonEncode({
          "isSuccess": true,
          "message": "Oki doki!",
          "data": encryptedData,
        }),
      );
    }
  });

  router.post('/data/contains', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null || dataDecrypted["tag"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box and tag parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      bool result = await zeytin.contains(
        truck,
        dataDecrypted["box"],
        dataDecrypted["tag"],
      );
      final encryptedData = ZeytinTokener(
        password,
      ).encryptMap({"contains": result});
      return Response.ok(
        jsonEncode({
          "isSuccess": true,
          "message": "Oki doki!",
          "data": encryptedData,
        }),
      );
    }
  });

  router.post('/data/search', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null ||
        dataDecrypted["field"] == null ||
        dataDecrypted["prefix"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box, field and prefix parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      var results = await zeytin.search(
        truck,
        dataDecrypted["box"],
        dataDecrypted["field"],
        dataDecrypted["prefix"],
      );
      final encryptedData = ZeytinTokener(
        password,
      ).encryptMap({"results": results});
      return Response.ok(
        jsonEncode({
          "isSuccess": true,
          "message": "Oki doki!",
          "data": encryptedData,
        }),
      );
    }
  });

  router.post('/data/filter', (Request request) async {
    final payload = await request.readAsString();
    final datas = jsonDecode(payload);

    final String? token = datas['token'];
    final String? data = datas['data'];
    if (token == null || data == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Token and data parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    var tokenData = getTokenData(token);
    if (tokenData == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "The token manager gave an error. Please verify the token's validity.",
          ).toMap(),
        ),
      );
    }
    String truck = tokenData["truck"];
    String password = tokenData["password"];
    var dataDecrypted = ZeytinTokener(password).decryptMap(data);
    if (dataDecrypted["box"] == null ||
        dataDecrypted["field"] == null ||
        dataDecrypted["value"] == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Box, field and value parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    } else {
      var results = await zeytin.filter(
        truck,
        dataDecrypted["box"],
        (map) => map[dataDecrypted["field"]] == dataDecrypted["value"],
      );
      final encryptedData = ZeytinTokener(
        password,
      ).encryptMap({"results": results});
      return Response.ok(
        jsonEncode({
          "isSuccess": true,
          "message": "Oki doki!",
          "data": encryptedData,
        }),
      );
    }
  });
}


============================================================
FILE: lib/routes/storage.dart
============================================================

import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as p;
import 'package:shelf/shelf.dart';
import 'package:shelf_multipart/shelf_multipart.dart';
import 'package:shelf_router/shelf_router.dart';
import 'package:mime/mime.dart';
import 'package:zeytin/logic/engine.dart';
import 'package:zeytin/models/response.dart';
import 'package:zeytin/routes/token.dart';

void storageRoutes(Zeytin zeytin, Router router) {
  router.post('/storage/upload', (Request request) async {
    final multipartRequest = request.multipart();

    if (multipartRequest == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opss...",
            error: "Multipart request expected.",
          ).toMap(),
        ),
      );
    }

    String? token;
    String? truckId;
    final forbiddenExtensions = [
      '.exe',
      '.sh',
      '.bat',
      '.php',
      '.py',
      '.js',
      '.htm',
      '.html',
      '.svg',
    ];

    await for (final part in multipartRequest.parts) {
      final contentDisposition = part.headers['content-disposition'];
      if (contentDisposition == null) continue;

      if (contentDisposition.contains('name="token"')) {
        token = await part.readString();
        final tokenData = getTokenData(token);
        if (tokenData != null) {
          truckId = tokenData["truck"];
        }
      }

      if (contentDisposition.contains('name="file"')) {
        if (token == null || truckId == null) {
          return Response.forbidden(
            jsonEncode(
              ZeytinResponse(
                isSuccess: false,
                message: "Opss...",
                error: "Invalid or missing token before file part.",
              ).toMap(),
            ),
          );
        }

        final match = RegExp(
          r'filename="([^"]+)"',
        ).firstMatch(contentDisposition);
        final fileName = match?.group(1) ?? "unnamed_file";
        final extension = p.extension(fileName).toLowerCase();

        if (fileName.contains('..') || !fileName.contains('.')) {
          return Response.forbidden(
            jsonEncode(
              ZeytinResponse(
                isSuccess: false,
                message: "Opss...",
                error: "The file name contains invalid characters!",
              ).toMap(),
            ),
          );
        }

        if (forbiddenExtensions.contains(extension)) {
          return Response.forbidden(
            jsonEncode(
              ZeytinResponse(
                isSuccess: false,
                message: "Risky file!",
                error:
                    "I know you're innocent. You're not a malicious hacker. But still, to be on the safe side, I can't accept these files.",
              ).toMap(),
            ),
          );
        }

        final storageDir = Directory("${zeytin.rootPath}/$truckId/storage");
        if (!await storageDir.exists()) {
          await storageDir.create(recursive: true);
        }

        final file = File(p.join(storageDir.path, fileName));
        final ios = file.openWrite();
        await ios.addStream(part);
        await ios.close();

        return Response.ok(
          jsonEncode(
            ZeytinResponse(
              isSuccess: true,
              message: "Oki doki!",
              data: {"url": "/$truckId/$fileName", "id": fileName},
            ).toMap(),
          ),
        );
      }
    }

    return Response.badRequest(
      body: jsonEncode(
        ZeytinResponse(
          isSuccess: false,
          message: "Opss...",
          error: "Missing file part.",
        ).toMap(),
      ),
    );
  });

  router.get('/<truckId>/<fileName>', (
    Request request,
    String truckId,
    String fileName,
  ) async {
    final filePath = "${zeytin.rootPath}/$truckId/storage/$fileName";
    final file = File(filePath);

    if (await file.exists()) {
      final contentType =
          lookupMimeType(fileName) ?? 'application/octet-stream';

      return Response.ok(
        file.openRead(),
        headers: {'Content-Type': contentType, 'Content-Disposition': 'inline'},
      );
    }

    return Response.notFound(
      jsonEncode(
        ZeytinResponse(
          isSuccess: false,
          message: "Opss...",
          error: "Dosya bulunamadı.",
        ).toMap(),
      ),
    );
  });
}


============================================================
FILE: lib/routes/token.dart
============================================================

import 'dart:convert';

import 'package:shelf/shelf.dart';
import 'package:shelf_router/shelf_router.dart';
import 'package:uuid/uuid.dart';
import 'package:zeytin/logic/account.dart';
import 'package:zeytin/logic/engine.dart';
import 'package:zeytin/models/response.dart';

List<Map<String, dynamic>> tokens = [];
void tokenRoutes(Zeytin zeytin, Router router) {
  router.post('/token/create', (Request request) async {
    final payload = await request.readAsString();
    final data = jsonDecode(payload);

    final String? email = data['email'];
    final String? password = data['password'];

    if (email == null || password == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error:
                "Email and password parameters are mandatory when making requests to this endpoint.",
          ).toMap(),
        ),
      );
    }
    String? myToken = getTokenByCredentials(email, password);
    if (myToken != null) {
      bool valid = isTokenValid(myToken);
      if (valid) {
        return Response.ok(
          jsonEncode(
            ZeytinResponse(
              isSuccess: true,
              message: "Oki doki!",
              data: {"token": myToken},
            ).toMap(),
          ),
        );
      } else {
        return await _createToken(zeytin, router, email, password);
      }
    } else {
      return await _createToken(zeytin, router, email, password);
    }
  });
  router.delete('/token/delete', (Request request) async {
    final payload = await request.readAsString();
    final data = jsonDecode(payload);

    final String? email = data['email'];
    final String? password = data['password'];

    if (email == null || password == null) {
      return Response.badRequest(
        body: jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "Opps...",
            error: "Credentials are required.",
          ).toMap(),
        ),
      );
    }

    final bool deleted = _deleteTokenByCredentials(email, password);

    if (deleted) {
      return Response.ok(
        jsonEncode(
          ZeytinResponse(
            isSuccess: true,
            message: "Token deleted successfully.",
          ).toMap(),
        ),
      );
    } else {
      return Response.notFound(
        jsonEncode(
          ZeytinResponse(
            isSuccess: false,
            message: "No active token found or invalid credentials.",
          ).toMap(),
        ),
      );
    }
  });
}

bool _deleteTokenByCredentials(String email, String password) {
  final initialLength = tokens.length;
  tokens.removeWhere(
    (element) => element['email'] == email && element['password'] == password,
  );
  return tokens.length < initialLength;
}

Future<Response> _createToken(
  Zeytin zeytin,
  Router router,
  String email,
  String password,
) async {
  ZeytinResponse zeytinResponse = await ZeytinAccounts.login(
    zeytin,
    email,
    password,
  );
  if (zeytinResponse.isSuccess) {
    String token = Uuid().v4();
    String id = zeytinResponse.data!["id"];
    tokens.add({
      "truck": id,
      "email": email,
      "password": password,
      "token": token,
      "create_at": DateTime.now().millisecondsSinceEpoch,
    });
    return Response.ok(
      jsonEncode(
        ZeytinResponse(
          isSuccess: true,
          message: "Oki doki!",
          data: {"token": token},
        ).toMap(),
      ),
    );
  } else {
    return Response.badRequest(body: jsonEncode(zeytinResponse.toMap()));
  }
}

Map<String, dynamic>? getTokenData(String token) {
  try {
    return tokens.firstWhere((element) => element['token'] == token);
  } catch (_) {
    return null;
  }
}

bool isTokenValid(String token) {
  final now = DateTime.now().millisecondsSinceEpoch;
  final index = tokens.indexWhere((element) => element['token'] == token);

  if (index == -1) {
    return false;
  }

  final tokenData = tokens[index];
  final createdAt = tokenData['create_at'] as int;

  if (now - createdAt > 120000) {
    tokens.removeAt(index);
    return false;
  }

  return true;
}

String? getTokenByCredentials(String email, String password) {
  try {
    final entry = tokens.firstWhere(
      (element) => element['email'] == email && element['password'] == password,
    );
    return entry['token'] as String;
  } catch (_) {
    return null;
  }
}


============================================================
FILE: lib/routes/watch.dart
============================================================

import 'dart:convert';
import 'package:shelf/shelf.dart';
import 'package:shelf_router/shelf_router.dart';
import 'package:shelf_web_socket/shelf_web_socket.dart';
import 'package:web_socket_channel/web_socket_channel.dart';
import 'package:zeytin/logic/engine.dart';
import 'package:zeytin/routes/token.dart';
import 'package:zeytin/tools/tokener.dart';

void watchRoutes(Zeytin zeytin, Router router) {
  router.get('/data/watch/<token>/<boxId>', (
    Request request,
    String token,
    String boxId,
  ) {
    return webSocketHandler((WebSocketChannel webSocket, _) {
      final tokenData = getTokenData(token);

      if (tokenData == null || !isTokenValid(token)) {
        webSocket.sink.add(jsonEncode({"error": "Unauthorized"}));
        webSocket.sink.close();
        return;
      }

      final String truckId = tokenData["truck"];
      final String password = tokenData["password"];
      final tokener = ZeytinTokener(password);

      final subscription = zeytin.changes.listen((change) {
        print(
          "WATCH DEBUG: Change detected in truck: ${change["truckId"]}, box: ${change["boxId"]}",
        );
        print("WATCH DEBUG: Expecting truck: $truckId, box: $boxId");

        if (change["truckId"] == truckId && change["boxId"] == boxId) {
          final payload = {
            "op": change["op"],
            "tag": change["tag"],
            "data": change["value"] != null
                ? tokener.encryptMap(change["value"])
                : null,
            "entries": change["entries"] != null
                ? tokener.encryptMap(change["entries"])
                : null,
          };
          webSocket.sink.add(jsonEncode(payload));
          print("WATCH DEBUG: Data sent to WebSocket!");
        }
      });

      webSocket.stream.listen(
        null,
        onDone: () {
          subscription.cancel();
        },
      );
    })(request);
  });
}


============================================================
FILE: lib/tools/ip.dart
============================================================

import 'package:shelf/shelf.dart';

 String getClientIp(Request request) {
  final xForwardedFor = request.headers['x-forwarded-for'];
  if (xForwardedFor != null && xForwardedFor.isNotEmpty) {
    return xForwardedFor.split(',').first.trim();
  }

  final xRealIp = request.headers['x-real-ip'];
  if (xRealIp != null && xRealIp.isNotEmpty) {
    return xRealIp;
  }
  final connInfo = request.context['shelf.io.connection_info'];
  if (connInfo != null) {
    return (connInfo as dynamic).remoteAddress.address;
  }

  return 'unknown';
}

============================================================
FILE: lib/tools/random_code.dart
============================================================

import 'dart:math';

int generateTenDigitRandomNumber() {
  final random = Random();
  int min = 1000000000;
  int max = 9999999999;
  
  int result = min + random.nextInt(max - min);
  return result;
}

============================================================
FILE: lib/tools/tokener.dart
============================================================

import 'dart:convert';
import 'dart:typed_data';
import 'package:crypto/crypto.dart';
import 'package:encrypt/encrypt.dart';

class ZeytinTokener {
  final Key key;
  final Encrypter encrypter;

  ZeytinTokener(String passphrase)
    : key = _deriveKey(passphrase),
      encrypter = Encrypter(AES(_deriveKey(passphrase), mode: AESMode.cbc));

  static Key _deriveKey(String passphrase) {
    final bytes = utf8.encode(passphrase);
    final hash = sha256.convert(bytes).bytes;
    return Key(Uint8List.fromList(hash));
  }

  String encryptMap(Map<String, dynamic> data) {
    final iv = IV.fromSecureRandom(16);
    final plainText = jsonEncode(data);
    final encrypted = encrypter.encrypt(plainText, iv: iv);
    return "${iv.base64}:${encrypted.base64}";
  }

  Map<String, dynamic> decryptMap(String encryptedData) {
    final parts = encryptedData.split(':');
    if (parts.length != 2) {
      throw FormatException("Invalid encrypted data format");
    }
    final iv = IV.fromBase64(parts[0]);
    final cipherText = parts[1];
    final decrypted = encrypter.decrypt(
      Encrypted.fromBase64(cipherText),
      iv: iv,
    );
    return jsonDecode(decrypted) as Map<String, dynamic>;
  }
}


============================================================
FILE: server/install.sh
============================================================

#!/bin/bash

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

set -e
clear

echo -e "${CYAN}>>> Zeytin & Nginx Auto-Installer${NC}"

sudo apt-get update -y
sudo apt-get install -y git curl unzip wget openssl nginx python3-venv

if ! command -v dart &> /dev/null; then
    wget -qO- https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo gpg --dearmor -o /usr/share/keyrings/dart.gpg
    echo 'deb [signed-by=/usr/share/keyrings/dart.gpg arch=amd64] https://storage.googleapis.com/download.dartlang.org/linux/debian stable main' | sudo tee /etc/apt/sources.list.d/dart.list
    sudo apt-get update -y && sudo apt-get install -y dart
fi

git clone https://github.com/JeaFrid/Zeytin.git || true
cd Zeytin
dart pub get

echo -e "\n${YELLOW}>>> Do you want to enable Live Streaming & Calls (Installs Docker + LiveKit)? (y/n)${NC}"
read -p "Choice: " INSTALL_LIVEKIT

if [[ "$INSTALL_LIVEKIT" == "y" ]]; then
    echo -e "${CYAN}Checking/Installing Docker...${NC}"
    
    if ! command -v docker &> /dev/null; then
        sudo apt-get install -y ca-certificates curl gnupg
        sudo install -m 0755 -d /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        sudo chmod a+r /etc/apt/keyrings/docker.gpg
        echo \
          "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
          "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
          sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        sudo apt-get update -y
        sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        sudo usermod -aG docker $USER
    fi

    LK_API_KEY="api$(openssl rand -hex 8)"
    LK_SECRET="sec$(openssl rand -hex 16)"
    PUBLIC_IP=$(curl -s ifconfig.me)
    echo -e "${CYAN}Deploying LiveKit Container...${NC}"
    sudo docker run -d --name zeytin-livekit \
        --restart unless-stopped \
        -p 7880:7880 \
        -p 7881:7881 \
        -p 7882:7882/udp \
        -e LIVEKIT_KEYS="${LK_API_KEY}: ${LK_SECRET}" \
        livekit/livekit-server --dev --bind 0.0.0.0

    echo -e "${GREEN}LiveKit deployed locally!${NC}"
    CONFIG_FILE="lib/config.dart"
    sed -i "s|static String liveKitUrl = \"\";|static String liveKitUrl = \"ws://${PUBLIC_IP}:7880\";|" $CONFIG_FILE
    sed -i "s|static String liveKitApiKey = \"\";|static String liveKitApiKey = \"${LK_API_KEY}\";|" $CONFIG_FILE
    sed -i "s|static String liveKitSecretKey = \"\";|static String liveKitSecretKey = \"${LK_SECRET}\";|" $CONFIG_FILE

    echo -e "${GREEN}Zeytin configuration updated with LiveKit credentials!${NC}"
fi


echo -e "\n${YELLOW}>>> Do you want to install and configure Nginx with SSL (Certbot via venv)? (y/n)${NC}"
read -p "Choice: " INSTALL_NGINX

if [[ "$INSTALL_NGINX" == "y" ]]; then
    read -p "Enter your Domain (e.g. api.example.com): " DOMAIN_NAME
    read -p "Enter your Email for SSL Alerts: " EMAIL_ADDR
    
    NGINX_CONF="/etc/nginx/sites-available/zeytin"
    
    echo -e "${CYAN}Writing Nginx configuration...${NC}"
    sudo bash -c "cat > $NGINX_CONF <<EOF
server {
    listen 80;
    server_name $DOMAIN_NAME;

    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }

    location / {
        proxy_pass http://127.0.0.1:12852;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \\\$http_upgrade;
        proxy_set_header Connection \"upgrade\";
        proxy_set_header Host \\\$host;
        proxy_cache_bypass \\\$http_upgrade;
        proxy_set_header X-Real-IP \\\$remote_addr;
        proxy_set_header X-Forwarded-For \\\$proxy_add_x_forwarded_for;
    }
}
EOF"

    sudo ln -sf $NGINX_CONF /etc/nginx/sites-enabled/
    sudo nginx -t
    sudo systemctl restart nginx

    echo -e "${CYAN}Setting up isolated Certbot environment...${NC}"
    sudo rm -rf /opt/certbot
    sudo mkdir -p /opt/certbot
    sudo python3 -m venv /opt/certbot/venv
    sudo /opt/certbot/venv/bin/pip install --upgrade pip
    sudo /opt/certbot/venv/bin/pip install certbot certbot-nginx

    echo -e "${CYAN}Requesting SSL Certificate via isolated Certbot...${NC}"
    sudo /opt/certbot/venv/bin/certbot --nginx -d $DOMAIN_NAME --non-interactive --agree-tos -m $EMAIL_ADDR --redirect
    sudo ln -sf /opt/certbot/venv/bin/certbot /usr/bin/certbot

    echo -e "${GREEN}Nginx and SSL configured for $DOMAIN_NAME${NC}"
    echo -e "${YELLOW}Note: Certbot set up a redirect from HTTP to HTTPS automatically.${NC}"
fi

echo -e "\n${GREEN}INSTALLATION COMPLETE! Run: dart runner.dart${NC}"

============================================================
FILE: server/runner.dart
============================================================

import 'dart:io';
import 'dart:async';

const String _kReset = '\x1B[0m';
const String _kBold = '\x1B[1m';
const String _kRed = '\x1B[31m';
const String _kGreen = '\x1B[32m';
const String _kYellow = '\x1B[33m';
const String _kCyan = '\x1B[36m';

const String logFile = 'zeytin.log';
const String pidFile = 'server.pid';
const String binaryPath = 'bin/server.exe';

void main() async {
  while (true) {
    print('\x1B[2J\x1B[0;0H');
    print(
      _kCyan +
          r'''
  _____                _     _           _ 
 |__  /   ___   _   _  | |_   (_)  _ __   | |
    / /   / _ \ | | | | | __| | | | '_ \  | |
   / /_  |  __/ | |_| | | |_  | | | | | | |_|
  /____|  \___|  \__, |  \__| |_| |_| |_| (_)
                 |___/
           SERVER MANAGER
''' +
          _kReset,
    );

    print('1. ${_kGreen}Start Test Mode (JIT)$_kReset');
    print('2. ${_kGreen}Start Live Mode (AOT Compilation)$_kReset');
    print('3. ${_kYellow}Watch Logs (tail -f)$_kReset');
    print('4. ${_kRed}Stop Server$_kReset');
    print('5. ${_kRed}UNINSTALL SYSTEM (Danger)$_kReset');
    print('6. ${_kCyan}UPDATE SYSTEM (Git & Deps)$_kReset');
    print('7. ${_kYellow}Clear Database & Storage$_kReset');
    print('8. ${_kCyan}Nginx & SSL Setup$_kReset');
    print('9. ${_kRed}Remove Nginx Config$_kReset');
    print('0. Exit');

    stdout.write('\n${_kBold}Choice: $_kReset');
    String? choice = stdin.readLineSync()?.trim();

    switch (choice) {
      case '1':
        await _checkAndManageLiveKit();
        await _startTestMode();
        break;
      case '2':
        await _checkAndManageLiveKit();
        await _startLiveMode();
        break;
      case '3':
        await _watchLogs();
        break;
      case '4':
        await _stopServer();
        break;
      case '5':
        await _uninstallSystem();
        break;
      case '6':
        await _updateSystem();
        break;
      case '7':
        await _cleanDatabase();
        break;
      case '8':
        await _setupNginx();
        break;
      case '9':
        await _removeNginx();
        break;
      case '0':
        exit(0);
      default:
        print('Invalid selection.');
        sleep(Duration(seconds: 1));
    }

    if (choice != '1' && choice != '3' && choice != '5') {
      stdout.write('\nPress ENTER to continue...');
      stdin.readLineSync();
    }
  }
}

Future<void> _startTestMode() async {
  print('\n$_kGreen[TEST] Starting JIT...$_kReset');
  var process = await Process.start(
    'dart',
    ['bin/server.dart'],
    mode: ProcessStartMode.inheritStdio,
    workingDirectory: _getProjectRoot(),
  );
  await process.exitCode;
}

Future<void> _startLiveMode() async {
  print('\n$_kCyan[BUILD] Compiling AOT binary...$_kReset');
  final root = _getProjectRoot();
  var res = await Process.run('dart', [
    'compile',
    'exe',
    'bin/server.dart',
    '-o',
    binaryPath,
  ], workingDirectory: root);

  if (res.exitCode != 0) {
    print('$_kRed[ERROR] Build failed: ${res.stderr}$_kReset');
    return;
  }

  var shellCmd = 'nohup ./$binaryPath > $logFile 2>&1 & echo \$! > $pidFile';
  await Process.run('bash', ['-c', shellCmd], workingDirectory: root);
  print('$_kGreen[SUCCESS] Server started in background.$_kReset');
}

Future<void> _stopServer() async {
  final root = _getProjectRoot();
  final pFile = File('$root/$pidFile');
  if (pFile.existsSync()) {
    String pid = pFile.readAsStringSync().trim();
    await Process.run('kill', [pid]);
    pFile.deleteSync();
    print('$_kGreen[STOP] Server (PID: $pid) stopped.$_kReset');
  } else {
    await Process.run('pkill', ['-f', binaryPath]);
    print('$_kYellow[INFO] Forced stop performed.$_kReset');
  }
}

Future<void> _watchLogs() async {
  final file = File('${_getProjectRoot()}/$logFile');
  if (!file.existsSync()) file.createSync();
  var process = await Process.start('tail', [
    '-f',
    file.path,
  ], mode: ProcessStartMode.inheritStdio);
  await process.exitCode;
}

Future<void> _updateSystem() async {
  print('\n$_kCyan[UPDATE] Starting system update...$_kReset');
  final root = _getProjectRoot();

  print('[@] Backing up local configs...');
  final hasConfig = await File('$root/lib/config.dart').exists();
  if (hasConfig) {
    await File('$root/lib/config.dart').copy('/tmp/zeytin_config.bak');
  }

  print('[@] Pulling latest changes from Git...');
  var gitRes = await Process.run('git', [
    'pull',
    'origin',
    'main',
  ], workingDirectory: root);

  if (gitRes.exitCode != 0) {
    print('$_kRed[ERROR] Git pull failed. Make sure it is a git repo.$_kReset');
  } else {
    print('$_kGreen[SUCCESS] Files updated.$_kReset');
  }

  if (hasConfig) {
    await File('/tmp/zeytin_config.bak').copy('$root/lib/config.dart');
    print('[@] Local config.dart restored.');
  }

  print('[@] Updating Dart dependencies...');
  var pubRes = await Process.start(
    'dart',
    ['pub', 'get'],
    mode: ProcessStartMode.inheritStdio,
    workingDirectory: root,
  );
  await pubRes.exitCode;

  print(
    '\n$_kGreen[COMPLETE] System updated. Please restart the server.$_kReset',
  );
}

Future<void> _uninstallSystem() async {
  print('\n$_kRed!!! DANGER ZONE !!!$_kReset');
  print('This will stop the server and DELETE ALL Zeytin files.');
  stdout.write('Type "DELETE" to confirm: ');
  if (stdin.readLineSync() != 'DELETE') {
    print('Aborted.');
    return;
  }

  await _stopServer();
  final root = _getProjectRoot();

  final destroyer =
      '''
#!/bin/bash
sleep 1
echo "Self-destructing..."
rm -rf "$root"
echo "Zeytin has been removed. Goodbye."
''';

  final scriptFile = File('/tmp/zeytin_uninstall.sh');
  await scriptFile.writeAsString(destroyer);
  await Process.run('chmod', ['+x', scriptFile.path]);

  print('$_kRed[BYE] Deleting system in 1 second...$_kReset');
  await Process.start('bash', [
    scriptFile.path,
  ], mode: ProcessStartMode.detached);
  exit(0);
}

Future<void> _cleanDatabase() async {
  stdout.write('Confirm deletion of ALL DATA? (y/n): ');
  if (stdin.readLineSync()?.toLowerCase() != 'y') return;
  await _stopServer();
  final root = _getProjectRoot();
  var dbDir = Directory('$root/zeytin');
  var dbErrDir = Directory('$root/zeytin_err');

  if (dbDir.existsSync()) dbDir.deleteSync(recursive: true);
  if (dbErrDir.existsSync()) dbErrDir.deleteSync(recursive: true);

  print('$_kRed[CLEAN] Database and error folders removed.$_kReset');
}

Future<void> _checkAndManageLiveKit() async {
  print('$_kCyan[INIT] Checking LiveKit status...$_kReset');
  try {
    var checkDocker = await Process.run('docker', ['--version']);
    if (checkDocker.exitCode != 0) return;
  } catch (e) {
    return;
  }
  var containerCheck = await Process.run('docker', [
    'ps',
    '-a',
    '--filter',
    'name=zeytin-livekit',
    '--format',
    '{{.Names}}',
  ]);

  if (containerCheck.stdout.toString().trim() == 'zeytin-livekit') {
    var runningCheck = await Process.run('docker', [
      'ps',
      '--filter',
      'name=zeytin-livekit',
      '--format',
      '{{.Names}}',
    ]);
    if (runningCheck.stdout.toString().trim().isEmpty) {
      print('$_kYellow[LIVEKIT] Container stopped. Starting...$_kReset');
      await Process.run('docker', ['start', 'zeytin-livekit']);
      print('$_kGreen[LIVEKIT] Started.$_kReset');
    } else {
      print('$_kGreen[LIVEKIT] Already running.$_kReset');
    }
  } else {
    print('$_kYellow[LIVEKIT] Not found. Skipping.$_kReset');
  }
}

Future<void> _setupNginx() async {
  final installScript = File('${_getProjectRoot()}/server/install.sh');
  if (!installScript.existsSync()) {
    print('$_kRed[ERROR] install.sh not found!$_kReset');
    return;
  }
  var process = await Process.start(
    'bash',
    [installScript.path],
    mode: ProcessStartMode.inheritStdio,
    workingDirectory: _getProjectRoot(),
  );
  await process.exitCode;
}

Future<void> _removeNginx() async {
  stdout.write('Confirm removing Nginx config for Zeytin? (y/n): ');
  if (stdin.readLineSync()?.toLowerCase() != 'y') return;

  await Process.run('sudo', ['rm', '/etc/nginx/sites-available/zeytin']);
  await Process.run('sudo', ['rm', '/etc/nginx/sites-enabled/zeytin']);
  await Process.run('sudo', ['systemctl', 'restart', 'nginx']);

  print('$_kGreen[SUCCESS] Nginx configuration removed.$_kReset');
}

String _getProjectRoot() {
  final scriptPath = Platform.script.toFilePath();
  final currentDir = Directory(scriptPath).parent.path;
  if (currentDir.endsWith('server')) {
    return Directory(currentDir).parent.path;
  }
  return currentDir;
}
